<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>G1参数设置</title>
    <url>/2018/05/10/G1%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h1><table>
<thead>
<tr>
<th>Option and Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx -Xms</td>
<td>最小和最大堆内存</td>
</tr>
<tr>
<td>-XX:MetaspaceSize -XX:MaxMetaspaceSize</td>
<td>永久代中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。java8 废除了永久代，使用元数据大小.</td>
</tr>
<tr>
<td>-XX:+UseG1</td>
<td>使用G1垃圾回收器.</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=n</td>
<td>你期望的GC最大暂停时间(50~200ms,对时延敏感的服务一般建议设置60ms)</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize</td>
<td>该参数取值范围是1 ~ 32，且必须为2的幂。JVM启动时会计算Region大小，其依据是使得整个堆被分为约2000个块。如堆大小为4G的话，G1HeapRegionSize会被设置为2MB.在程序运行过程中，如果发现GC日志中出现大量的Humongous Allocation，说明程序产生了很多巨型对象（超过Region大小一半），这些对象容易导致内存碎片，且在jdk8u40前的版本中其回收过程不够优化。此时应该适当调大G1HeapRegionSize的值，使得一部分超过原Region大小一半的对象在新的RegionSize下不再显得那么大。</td>
</tr>
<tr>
<td>-XX:G1ReservePercent</td>
<td>在G1中，有一部分内存会被预留出来，当Survivor区容量不足时，这块区域会暂时顶上。默认值为10，即10%的堆空间被预留下来。如果GC日志中出现to-space-exhuasted，可以调大该参数解决。</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>控制对象晋升到老年代的年龄阈值。可以通过-XX:+PrintTenuringDistribution打出Survivor区中对象的年龄分布情况，找出能够有效老化对象的年龄值。如果Survivor区的对象在到达某个年龄后，只见年龄增加但对象所占内存几乎没有减少，那么就可以把MaxTenuringThreshold设置为该值，让Survivor区的对象及时晋升到老年代。如果在日志中发现Survivor区空间占用一直比较大，新生代垃圾收集时间较长，可考虑缩小最大年龄阈值，让Survivor区的对象尽早进入老年代。</td>
</tr>
<tr>
<td>-XX:G1MaxNewSizePercent</td>
<td>控制对象晋升到老年代的年龄阈值。可以通过-XX:+PrintTenuringDistribution打出Survivor区中对象的年龄分布情况，找出能够有效老化对象的年龄值。如果Survivor区的对象在到达某个年龄后，只见年龄增加但对象所占内存几乎没有减少，那么就可以把MaxTenuringThreshold设置为该值，让Survivor区的对象及时晋升到老年代。如果在日志中发现Survivor区空间占用一直比较大，新生代垃圾收集时间较长，可考虑缩小最大年龄阈值，让Survivor区的对象尽早进入老年代。</td>
</tr>
<tr>
<td>-XX:G1MaxNewSizePercent</td>
<td>G1主要通过调整新生代大小来达到暂停时间的要求，默认的新生代可变范围是5% ~ 60%。G1MaxNewSizePercent控制新生代大小的上限，该值默认为60%。如果Survivor区对象占用的空间波动剧烈，G1的暂停时间可能会有抖动，可以通过降低G1MaxNewSizePercent参数缓解。使用该参数时，需要加上-XX:+UnlockExperimentalVMOptions解锁实验性参数，该参数需在满足Survivor区占用剧烈变动的条件下才使用，其他情况下慎用。</td>
</tr>
</tbody></table><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=你期望的GC最大暂停时间(50~200ms,对时延敏感的服务一般建议设置60ms) -XX:MaxTenuringThreshold=15</span><br><span class="line">-XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime</span><br><span class="line">-Xloggc:/home/work/log/xxx_service/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure>

<p>以上为生产环境的G1配置example。</p>
<h1 id="G1定位问题速查"><a href="#G1定位问题速查" class="headerlink" title="G1定位问题速查"></a>G1定位问题速查</h1><table>
<thead>
<tr>
<th>日志中出现to-space-exhuasted</th>
<th>增大-XX:G1ReservePercent</th>
</tr>
</thead>
<tbody><tr>
<td>日志中Humongous Allocation频繁出现</td>
<td>增大-XX:G1HeapRegionSize</td>
</tr>
<tr>
<td>Young GC暂停时间长，Survivor区占用一直比较大</td>
<td>减小-XX:MaxTenuringThreshold</td>
</tr>
<tr>
<td>Young GC暂停时间抖动，Survivor区占用变化剧烈</td>
<td>减小-XX:G1MaxNewSizePercent</td>
</tr>
<tr>
<td>GC暂停时间长</td>
<td>减小-XX:MaxGCPauseMillis（不要低于50ms）</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">深入探究JVM | 探秘 Metaspace</a></p>
</li>
<li><p><a href="http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html" target="_blank" rel="noopener">Garbage First Garbage Collector Tuning</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A" target="_blank" rel="noopener">Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>G1垃圾回收器</title>
    <url>/2018/05/03/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><ul>
<li>像CMS收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要GC停顿时间更好预测。</li>
<li>不希望牺牲大量的吞吐性能。</li>
<li>不需要更大的Java Heap。</li>
</ul><p>G1 的出现就是为了干掉CMS。它同CMS相比，在以下方面表现的更出色：</p><ul>
<li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li>
<li>G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li>
</ul><a id="more"></a>


<h1 id="G1-Heap-Allocation"><a href="#G1-Heap-Allocation" class="headerlink" title="G1 Heap Allocation"></a>G1 Heap Allocation</h1><p><img src="/2018/05/03/G1垃圾回收器/HeapStructure.png" alt></p>
<p><img src="/2018/05/03/G1垃圾回收器/Slide9.PNG" alt></p>
<p>serial, parallel, CMS把垃圾回收器分成上面几个部分：Young Generation、Old Generation、Permanent Generation。在内存管理上，G1依然采用<strong>分代</strong> 的内存管理方式，但是跟以往的垃圾回收算法不同的是，G1将整个堆划分成很多大小相同的小块，这些小块称为Region。Eden区、Survivor区、老年区都由若干Region组成，并且这些Region的数量在程序运行中是可变的。</p>
<ul>
<li>Eden区</li>
<li>Survivor区</li>
<li>Old Generation<ul>
<li>Humongous区。当需要分配一个超过Region一半大小的大对象时。</li>
</ul>
</li>
</ul>
<p>region具有如下的一些特点:</p>
<ul>
<li>整个堆被分作大约2000个rigion.</li>
<li>region在分代之间不连续</li>
<li>Minimum = 1Mb,  maximum = 32Mb</li>
</ul>
<h1 id="Young-GC-in-G1"><a href="#Young-GC-in-G1" class="headerlink" title="Young GC in G1"></a>Young GC in G1</h1><p><img src="/2018/05/03/G1垃圾回收器/Slide11.PNG" alt></p>
<ul>
<li>是否Stop the World： 是</li>
<li>触发条件：Eden区被填满</li>
<li>过程：Eden区存活对象拷贝至Survivor，Survivor区存活对象如果年龄小于阈值则拷贝至其他Survivor Region，否则会被提升至老年代Region中。</li>
</ul>
<p>年轻代大小会根据设定的最大暂停时间进行自适应调整。一个基本假定是：空间越大，回收越慢，空间越小，回收越快，G1会据此调整堆的大小以满足暂停时间的要求。</p>
<h1 id="Old-GC-in-G1"><a href="#Old-GC-in-G1" class="headerlink" title="Old GC in G1"></a>Old GC in G1</h1><ul>
<li>是否Stop the World：部分阶段Stop the World</li>
<li>触发条件：<ul>
<li>整个堆空间的使用率达到特定的值（通过InitiatingHeapOccupancyPercent控制，默认45%）</li>
<li>大对象分配</li>
</ul>
</li>
<li>过程</li>
</ul>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(1) Initial Mark<em>(Stop the World Event)</em></td>
<td>This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.</td>
</tr>
<tr>
<td>(2) Root Region Scanning</td>
<td>Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.</td>
</tr>
<tr>
<td>(3) Concurrent Marking</td>
<td>Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.</td>
</tr>
<tr>
<td>(4) Remark<em>(Stop the World Event)</em></td>
<td>Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector.</td>
</tr>
<tr>
<td>(5) Cleanup<em>(Stop the World Event and Concurrent)</em></td>
<td>Performs accounting on live objects and completely free regions. (Stop the world)Scrubs the Remembered Sets. (Stop the world)Reset the empty regions and return them to the free list. (Concurrent)</td>
</tr>
<tr>
<td>(<em>) Copying</em>(Stop the World Event)*</td>
<td>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as <code>[GC pause (young)]</code>. Or both young and old generation regions which are logged as <code>[GC Pause (mixed)]</code>.</td>
</tr>
</tbody></table>
<h1 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h1><p>G1的Full GC与CMS一样，都是用Serial Old垃圾收集器。特别是G1一般用在大内存的场景下，其后果更加严重。</p>
<p>G1场景下发生Full GC的通常原因：</p>
<p>（1）元空间耗尽(MetaspaceSize, 对应原来的永久代，java8废除了永久代)</p>
<p>（2）to space exhausted</p>
<p>（3）对象产生及提升太快，在并发标记阶段完成之前就填满了堆空间</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></li>
<li><a href="http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html" target="_blank" rel="noopener">Garbage First Garbage Collector Tuning</a></li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>GC区域</title>
    <url>/2018/05/03/GC%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="回收区域"><a href="#回收区域" class="headerlink" title="回收区域"></a>回收区域</h1><ul>
<li>GC区域：<strong>堆、方法区</strong></li>
<li>不GC的区域：程序计数器、虚拟机栈、本地方法栈</li>
</ul><h2 id="堆回收"><a href="#堆回收" class="headerlink" title="堆回收"></a>堆回收</h2><ul>
<li>引用计数法：有引用就会记1<ul>
<li>会有循环引用的问题</li>
<li>主流jvm不使用这种方式</li>
</ul>
</li>
<li>可达性分析法：判断到GC-root<ul>
<li>GC root 对象<ul>
<li>jvm中栈帧中引用的对象</li>
<li>方法区中静态属性(static)、常量(final)引用的对象</li>
</ul>
</li>
</ul>
</li>
<li>引用分类<ul>
<li>强引用：<code>Object ojb = new Object()</code>， 只要有强引用，不会被GC</li>
<li>软引用：可以用<code>SoftReference</code>来实现。内存溢出时，进行二次回收。第二次还没有足够内存，抛内存溢出异常。</li>
<li>弱引用：可以用<code>WeakReference</code>来实现。只能生存到下一次GC之前。无论内存是否够，都会被GC.</li>
<li>虚引用：可以用<code>PhantomReference</code>来实现。GC时会收到一个系统通知。</li>
<li>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</li>
</ul>
</li>
</ul><a id="more"></a>

<ul>
<li>什么时候回收<ul>
<li>如果对象不可达，判断是否需要执行<code>finalize()</code>方法<ul>
<li>不需要执行<code>finalize()</code> 的情况：<ul>
<li>没有<code>overwrite</code> <code>finalize()</code>方法</li>
<li>虚拟机已经执行过一次<code>finalize()</code></li>
</ul>
</li>
</ul>
</li>
<li>如果需要执行<code>finalize()</code>方法， 放入<code>F-Queue</code>中，在<code>finalize()</code>执行完后还是满足回收的条件，宣判“死刑”被回收。</li>
</ul>
</li>
</ul>
<h2 id="方法区（永久代）回收"><a href="#方法区（永久代）回收" class="headerlink" title="方法区（永久代）回收"></a>方法区（永久代）回收</h2><p>方法区回收的能够回收的空间有限。</p>
<ul>
<li>回收：<ul>
<li>废弃常量：无引用，和heap类似。</li>
<li>无用的类必须满足的条件<ul>
<li>java堆中不存在该类的任何对象</li>
<li>加载该类的<code>classLoader</code>已经被回收</li>
<li>这个类对应的<code>java.lang.class</code> 对象没有在任何地方被引用。</li>
</ul>
</li>
</ul>
</li>
<li>class类扩展<ul>
<li>因为java是运行时类型识别，<code>class</code> 类是保存这些识别信息的类，即：保存了每个对象的类型信息。可以通过这些信息反射创建一个实例。判断一下有没有引用就理所当然了，因为如果有引用，那么就可能有对这个对象类型信息的依赖，就不可以被回收。</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">深入探究JVM | 探秘 Metaspace</a></li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>GC算法和分代回收设计</title>
    <url>/2018/05/03/GC%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="gc算法分类"><a href="#gc算法分类" class="headerlink" title="gc算法分类"></a>gc算法分类</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>算法实现：</p><ul>
<li>标记。</li>
<li>清除。</li>
</ul><p>缺点：</p><ul>
<li>标记和清除两个阶段效率不高</li>
<li>会产生内存碎片，无法分配大对象</li>
</ul><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决 <strong>标记-清除算法的效率不高</strong> 的问题。</p><p>算法实现：</p><ul>
<li>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块</li>
<li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面</li>
<li>一次性清除使用过的内存</li>
</ul><a id="more"></a>






<p>优点：</p>
<ul>
<li>只需要移动一下指针，顺序分配内存即可，效率高</li>
<li>同时也不会有内存碎片的问题</li>
</ul>
<p>缺点：</p>
<ul>
<li>内存缩小为原来的一半</li>
<li>如果存活的对象比较多的时候就会复制较多的存活对象，效率降低</li>
</ul>
<p>根据缺点知道，适用于对象被频繁创建和GC的场景，如果对象长期存在的较多，那么就会导致花费大量时间在复制存活对象上，效率降低。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>为了解决 <strong>复制算法内存占用过高、复制较多存活对象效率</strong>问题而设计。</p>
<p>算法实现：</p>
<ul>
<li>标记</li>
<li>整理的时候让存活对象向一端移动，直接清理掉边界以外的内存。</li>
</ul>
<h1 id="GC分代"><a href="#GC分代" class="headerlink" title="GC分代"></a>GC分代</h1><h2 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代?"></a>为什么要分代?</h2><ul>
<li>对象的<strong>生命周期</strong> 不一样。有的对象是“朝生夕死”，有的对象存活的时间就比较长。</li>
<li>如果不分代，我们要对对的所有区域进行扫描，<strong>效率</strong> 不高</li>
<li>充分发挥不同<strong>GC算法</strong> 。</li>
</ul>
<h2 id="如何分代"><a href="#如何分代" class="headerlink" title="如何分代"></a>如何分代</h2><p><img src="/2018/05/03/GC算法和分代回收设计/1.png" alt="这里写图片描述"></p>
<h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>存放生命周期较短的对象。一般使用<strong>复制算法</strong>进行GC.</p>
<ul>
<li>构成：<code>Eden</code>区、2个<code>Survivor</code>区（分别叫<code>from</code>和<code>to</code>）。</li>
<li>GC:<ul>
<li>最开始对象存在于: <code>Eden</code>区和<code>Survivor</code> 的<code>from</code>, <code>To</code>区是空的。</li>
<li>进行GC，<ul>
<li><code>Eden</code>区：所有存活对象被复制到 <code>To</code></li>
<li>from区：大于<code>XX:MaxTenuringThreshold</code>移到年老代, 反之复制到<code>To</code></li>
</ul>
</li>
<li>Eden 和 from区已经被清空，被清空的from区就相当于最开始的To区域 </li>
<li>回到最开始的状态</li>
</ul>
</li>
<li>相关参数<ul>
<li>-Xms 20M ：最小堆内存</li>
<li>-Xmx 20M： 最大堆内存</li>
<li>-Xmn 10M：新生代大小<ul>
<li>-XXSurvivorRatio=8 新生代中<code>Eden</code>区和<strong>其中一个</strong> Survivor区的比例( <strong>8:1:1</strong>)。</li>
<li>eden space: 8192k</li>
<li>from space: 1024k</li>
<li>to space: 1024k</li>
</ul>
</li>
</ul>
</li>
<li>为什么很多服务都把 -Xms 和 -Xmx都设置成一样？<ul>
<li>减少初期GC带来的抖动</li>
<li>避免JVM在运行过程中向OS申请内存,发生内存抖动</li>
</ul>
</li>
</ul>
<h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>存放生命周期长的对象。经历过N次回收之后，仍然存活的对象。一般使用<strong>标记-整理</strong>算法GC，但是常用的CMS是标记-清除算法。</p>
<h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>对应前一篇笔记的：方法区。常量、类等。</p>
<h2 id="GC的触发"><a href="#GC的触发" class="headerlink" title="GC的触发"></a>GC的触发</h2><ul>
<li><p>Partial GC：并不收集整个GC堆的模式</p>
<ul>
<li>Young GC：只收集young gen的GC</li>
</ul>
<ul>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
</li>
<li><p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p>
</li>
</ul>
<p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p>
<ul>
<li>young GC：当young gen中的<strong>eden区分配满</strong>的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li>
<li>full GC：<ul>
<li>当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；</li>
<li>或者如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；</li>
<li>或者System.gc()、heap dump带GC，默认也是触发full GC。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap内部实现原理</title>
    <url>/2019/05/03/HashMap%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>hash链表实现冲突.</li>
</ul><ul>
<li>hash算法<ul>
<li>取hashcode。int的有符号数，<strong>-2147483648</strong>到<strong>2147483648</strong>，直接映射hash内存放不下的。</li>
<li>高位运算。利用<strong>搅动函数</strong> 。<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</li>
<li>取模运算。做了优化，因为bucket的大小总是 $2^N$, 经过搅动函数之后的hashCode满足：<ul>
<li>$hashCode \bmod 2^N = hashCode \wedge (2^{N} -1)$ </li>
</ul>
</li>
</ul>
</li>
</ul><a id="more"></a>

<p><img src="/2019/05/03/HashMap内部原理/%E8%BF%90%E7%AE%97.jpg" alt></p>
<ul>
<li>扩容机制<ul>
<li>冲突大于8，由链表转为红黑树.</li>
<li>扩容的大小为$2^{N}$</li>
</ul>
</li>
</ul>
<p><img src="/2019/05/03/HashMap内部原理/hashMap-put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p>
<ul>
<li>线程安全.<ul>
<li>ConcurrentHashMap线程安全.分段锁实现。</li>
</ul>
</li>
</ul>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li>
<li><a href="https://www.zhihu.com/question/20733617/answer/111577937" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询如何优化</title>
    <url>/2019/07/31/MySQL%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h1><p>对这个问题有兴趣是源于一次开发中遇到要统计人数的需求。类似于“得到”专栏的订阅数。</p><p><img src="/2019/07/31/MySQL查询如何优化/dedao.png" alt="得到统计"></p><p>但是我的数据量比这个大很多，而对数据的准确性要求就不那么高。所以首先要明确需求。其他答案有的说了用缓存，有的答案对比了count(*)、count(1)的区别，都很好，但是我认为还是要看一下题主的场景。我根据我实际开发的经验总结如下几个方面，FYI。</p><a id="more"></a>


<p><img src="/2019/07/31/MySQL查询如何优化/daotu.png" alt="思维导图"></p>
<h1 id="数据量大-准确性要求低-请求量大"><a href="#数据量大-准确性要求低-请求量大" class="headerlink" title="数据量大/准确性要求低/请求量大"></a>数据量大/准确性要求低/请求量大</h1><ol>
<li>这种场景一般是C端产品，比如上面说的得到APP的订阅数目，如果对一致性要求不高，可以直接在内存中使用缓存，用guava在内存中做一个缓存定时刷新即可，百万量级count(*)有缓存的频率还不至于有啥性能问题；</li>
<li>但是内存内缓存有一个问题就是不同服务器之间的缓存数量是不一致的，可以考虑用redis作为计数，一般这种场景是大多数同学遇到的，简单粗暴搞定即可；</li>
<li>用show table status。这个建议还是不要用了，翻了下mysql 的doc，40%的误差概率，碰上就有点大了呀。</li>
</ol>
<blockquote>
<p>TABLE_ROWS<br>The number of rows. Some storage engines, such as MyISAM, store the exact count. For other storage engines, such as InnoDB, this value is an approximation, and may vary from the actual value by as much as 40% to 50%. In such cases, use SELECT COUNT(*) to obtain an accurate count.</p>
</blockquote>
<h1 id="数据量大-准确性要求高-请求量一般"><a href="#数据量大-准确性要求高-请求量一般" class="headerlink" title="数据量大/准确性要求高/请求量一般"></a>数据量大/准确性要求高/请求量一般</h1><p>这种场景一般出现在账务上，比如有多少人打款。而且估计DAU在亿级别的公司可能才会遇到。这里最关键的问题还是一致性的要求。在并发系统中，看看我们用redis，我们看看会出现什么样的一致性问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间       A processor         B processor</span><br><span class="line">T1         插入数据</span><br><span class="line">T2                             1.redis#get计数器；2. 查询最新的N条数据</span><br><span class="line">T3         redis#incr</span><br></pre></td></tr></table></figure>

<p>在T2的时间点的时候会出现数据不一致，B看到的是数据已经更新，但是数据库还没更新。我们就在想，如果放到一个事务里面，就可以完美解决这个问题了呀。由于事务，innoDB不支持像MyISAM准确计数，解铃还须系铃人，所以我们建一个计数表（count_table）+事务，解这个问题了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间         会话A                            会话B</span><br><span class="line">T1         begin;</span><br><span class="line">           在计数表中插入一条数据;</span><br><span class="line">T2                                          begin;</span><br><span class="line">                                            1. 读count_table；</span><br><span class="line">                                            2. 查询最新的N条数据</span><br><span class="line">                                            commit;</span><br><span class="line">T3         更新conut_table;</span><br><span class="line">           commit;</span><br></pre></td></tr></table></figure>

<p>在T1的时候，如果采用Mysql默认的事务隔离级别：读提交。因为T1事务还没有提交，所以插入的数据，B是读不到的，所以从逻辑上来说是一致的。</p>
<h1 id="数据量大-准确性要求高-请求量特别高"><a href="#数据量大-准确性要求高-请求量特别高" class="headerlink" title="数据量大/准确性要求高/请求量特别高"></a>数据量大/准确性要求高/请求量特别高</h1><p>抱歉，没遇到过。如果你觉得你遇到了，你的架构需要你重新design and review，相信我。</p>
<h1 id="带条件count"><a href="#带条件count" class="headerlink" title="带条件count(*)"></a>带条件count(*)</h1><p>很多时候我们的业务场景不是数据量多，而是条件复杂。这其实就是一个查询优化的问题了，和是不是count(*)没有关系，那么有以下两招常用，这个得具体问题具体分析了。比如时间维度可以加一个索引来优化；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table_name where a = x and b = x;</span><br></pre></td></tr></table></figure>

<ul>
<li>加索引</li>
<li>业务拆分</li>
</ul>
<h1 id="count性能比较"><a href="#count性能比较" class="headerlink" title="count性能比较"></a>count性能比较</h1><ul>
<li>count(primary key)。遍历整个表，把主键值拿出来，累加；</li>
<li>count(1)。遍历整个表，但是不取值，累加；</li>
<li>count(非空字段)。遍历整个表，读出这个字段，累加；</li>
<li>count(可以为空的字段)。遍历整个表，读出这个字段，判断不为null累加；</li>
<li>count(*)。遍历整个表，做了优化，不取值，累加。</li>
</ul>
<p>结合mysql的一些索引查询知识，我们可以大致得出如下结论。</p>
<p><img src="/2019/07/31/MySQL查询如何优化/cmp.png" alt="count性能比较"></p>
<p>建议直接使用count(*)。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈code-review</title>
    <url>/2019/09/15/best-practice-for-code-review/</url>
    <content><![CDATA[<p>上一篇文章写了<a href="https://acceml.github.io/2017/11/10/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9A%84design/" target="_blank" rel="noopener">如何做好design</a>，其实也是一个如何指导新人，做design review的方法论。由于tech leader是一个有代码洁癖的人，组内的代码互相review一直都特别严格，经常一份小代码提了数十个comments。这里同样总结一些方法论，如何做好code review。</p><h1 id="None-goal"><a href="#None-goal" class="headerlink" title="None-goal"></a>None-goal</h1><a id="more"></a>
<p>在谈code review之前，我觉得有必要强制一下code style。避免code review的时间浪费在空格、命名规范等不痛不痒的事情上。由于笔者主语言是java，这里推荐三个插件或包：</p>
<ul>
<li>lombok。<code>@Slf4j</code>、<code>@Getter</code> 、<code>@Setter</code> 注解可以达到简化代码的目的;</li>
<li>checkstyle。强烈建议加上这个插件，统一团队代码风格，如果出现magic number、illegal blank、参数过多，代码超过多长等的时候直接compile failure;</li>
<li>findbug。可以发现一些潜在的bug。 </li>
</ul>
<p>此外，一些基本的命名风格，如DTO、DAO的命名等，可参考<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">阿里巴巴java开发指南终极版本</a>。</p>
<p>code review 不应该包括：设计模式，架构变动这些东西，这些东西应该是在design review上面，而不是code review可以说清楚的。</p>
<p>code review不积极，如何鼓励大家code review、业务发展太快不能review等问题不在本文讨论之列。</p>
<h1 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul>
<li>包的是否有SNAPSHOT</li>
<li>引入新的包是不是和已有功能是不是能承载了，比如判断一个Map、List是不是空，就有spring、apache、guava等包，团队尽量保持一致；json的包那么多，使用一个就好。</li>
</ul>
<h2 id="style-amp-amp-clean"><a href="#style-amp-amp-clean" class="headerlink" title="style&amp;&amp;clean"></a>style&amp;&amp;clean</h2><ul>
<li><p>遍历的方式。如果用lamda就都用lamda，不要一边lamda一边又for()，当然复杂情况ok。</p>
</li>
<li><p>debug日志代码不要出现在master branch。</p>
</li>
<li><p>for循环中break,continue的方式。比如通常的循环都可以先写break，再写continue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (CommonAd commonAd : candidateApps) &#123;</span><br><span class="line">  	<span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">    xxx;<span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种if之间如果是逻辑段要空行.</p>
</li>
<li><p>禁止出现大段代码相同.</p>
</li>
<li><p>不要提前new Object。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>()&#123;</span><br><span class="line">  App app = <span class="keyword">new</span> App();<span class="comment">//这里就可能被continue掉。</span></span><br><span class="line">  <span class="keyword">if</span>(xxx)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>参数分行了就一行一个参数。</p>
</li>
<li><p>lamda转行的时候保持风格统一，通常是这样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">  .filter()</span><br><span class="line">  .map()</span><br><span class="line">  .Collector()</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h2 id="命名-amp-amp-声明"><a href="#命名-amp-amp-声明" class="headerlink" title="命名&amp;&amp;声明"></a>命名&amp;&amp;声明</h2><ul>
<li>无用的变量。有的时候代码改动较多的时候，经常会<code>@Autowired</code> 一个bean结果没用到。</li>
<li>静态变量的声明。是不是有重复、或者可以提高到公用的Utils。</li>
<li>变量的命名要一目了然。不要出现index, i,j,k等变量，所有的变量命名都要有意义。</li>
<li>magic string。magic number可以用checkstyle检查出来，但是有的变量也必须要声明的，不然后面读代码会有一种想死的冲动。</li>
<li>注释的相关性和清晰度以及是不是需要注释。</li>
</ul>
<h2 id="数据结构-amp-amp-API"><a href="#数据结构-amp-amp-API" class="headerlink" title="数据结构&amp;&amp;API"></a>数据结构&amp;&amp;API</h2><ul>
<li><p>Map里面只放所需要的变量，不要随便就addAll()。</p>
</li>
<li><p>不要随便new xxxList。用Collections.emptyList()替代，存储做了优化。</p>
</li>
<li><p>使用set还是sublist；使用linkedList还是ArrayList诸如此类。</p>
</li>
<li><p>有没有现成的api。</p>
</li>
<li><p>保持类的单一职责原则。避免过度耦合不可维护。</p>
</li>
<li><p>避免在运行时计算，比如在都是变量的话，恰好这两个变量相关，提前计算好，不要在执行代码的时候计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> A = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> A_B = A / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的单一职责，要么拆方法，要么换名字。保大的还是保小的你总要选一个(跑偏了…)</p>
</li>
</ul>
<h2 id="监控-amp-amp-日志"><a href="#监控-amp-amp-日志" class="headerlink" title="监控&amp;&amp;日志"></a>监控&amp;&amp;日志</h2><ul>
<li>counter不要随便。该加counter的时候要加，线上业务是不是关心这个请求。</li>
<li>离线日志只在出入口打，除非特殊需要。</li>
</ul>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul>
<li><a href="https://www.zhihu.com/question/41089988" target="_blank" rel="noopener">大家的公司的code review都是怎么做的？遇到过什么问题么？</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>codereview</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm命令使用</title>
    <url>/2018/05/10/jvm%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -histo [pid]</span><br></pre></td></tr></table></figure><p>用<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">工具</a>查看</p><h2 id="内存dump-分析工具-Eclipse-Memory-Analyzer-Tool"><a href="#内存dump-分析工具-Eclipse-Memory-Analyzer-Tool" class="headerlink" title="内存dump 分析工具-Eclipse Memory Analyzer Tool"></a>内存dump 分析工具-Eclipse Memory Analyzer Tool</h2><p><code>jmap -dump:live,format=b,file=[文件名] [pid]</code></p><ul>
<li><p>MAT是什么？个基于Eclipse的内存分析工具，是一个快速、功能丰富的<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java </a>heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p>
</li>
<li><p><a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载地址</a></p>
</li>
<li><p>一般的内存dump文件较大，可以通过调整下载下来的文件夹中 MemoryAnalyzer.ini 来调整MAT使用内存大小， 参数为 -vmargs -Xmx3072m(解决imprt error的问题)</p>
</li>
</ul><a id="more"></a>




<h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><ul>
<li><p>Class Name ： 类名称，java类名</p>
</li>
<li><p>Objects ： 类的对象的数量，这个对象被创建了多少个</p>
</li>
<li><p>Shallow Heap ：一个对象内存的消耗大小，不包含对其他对象的引用</p>
</li>
<li><p>Retained Heap ：是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和</p>
</li>
<li><p>class name 支持 Regex搜</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka简介</title>
    <url>/2017/09/28/kafka%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>起源于Linkedin，在apache开源，基于发布订阅的分布式消息系统。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>高吞吐量：单机每秒几百MB的读写<br>消息持久化<br>高扩展性<br>高可靠性<br>支持多消费者（这个是比较重要的特点）</p><h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker<br>Producer: 负责发布消息到Kafka broker<br>Consumer: 消息消费者，向Kafka broker读取消息的客户端<br>Consumer Group: 每个Consumer属于一个特定的Consumer Group<br><img src="/2017/09/28/kafka简介/1.png" alt="这里写图片描述"></p><a id="more"></a>


<ol>
<li><p>broker、producer、consumer这三个在所有消息队列中都有。这里注意一下consumer group的概念,如图所示，hadoop cluster、real-time monitoring、otherservice、datawarehouse分别是四个不同的集群，每一个集群中有成百上千个消费者，但是这时候如果发送了一条helloworld的消息，这四个集群中只有四个consumer客户端可以接收到这条消息，每个集群中只有一个consumer客户端可以消费到消息。这就是kafka 支持多消费者。</p>
</li>
<li><p>kafka用zookeeper来做配置中心，用于协调各节点、consumer 之间的关系。但是图中的线可以看到kafka中producer并不和 zookeeper保持相连。</p>
</li>
</ol>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>有三个比较基础的概念。</p>
<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>逻辑上的队列;</p>
<h2 id="Patition"><a href="#Patition" class="headerlink" title="Patition"></a>Patition</h2><p>物理上把Topic分成多个Partition;<br>一个topic分布在多个broker上(为了负载均衡和备份，很多分布式组件都有这种设计，如mongodb的sharding)。<br>1.如上图，假设我们的kafka集群有3个broker，创建了1个topic，这个topic我们创建的时候指定它的partition为3，这时候partition就会平均分布到每个broker上，1个broker上面有一个partition(物理上分开)，但是这三个partition仍然属于同一个topic(逻辑上还是一个队列)。</p>
<p>2.如图所示，kafka只保证partition级别的有序。</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="/2017/09/28/kafka简介/2.png" alt="这里写图片描述"><br>kafka在业界的使用主要还是用来处理日志，因为像flink、storm、spark这些大数据中间件和kafka对接得很好，也可以用来做业务逻辑处理，主要是多消费者的情况,同学们可以结合自己的情况做方案设计。<br>前段时间《架构师》上面推送了《有赞日志统一平台初探》，这是有赞团队的日志处理系统，其他的日志处理系统也大同小异。包括日志接入、日志传输、日志处理、日志存储。在日志处理的时候由于支持多消费者，可以在这里用spark做实时数据分析，也可以直接在这里做简单的处理做重要日志备份、也可以根据业务需要做离线的日志分析。<br><img src="/2017/09/28/kafka简介/3.png" alt="这里写图片描述"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">kafka官方文档</a><br><a href="http://tech.youzan.com/you-zan-tong-ri-zhi-ping-tai-chu-tan/?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">有赞日志统一平台</a></p>
<blockquote>
<p>程序员在跟宇宙赛跑，他们在努力开发出更大更好的傻瓜程序，而宇宙则努力培养出更大更好的白痴。到目前为止，宇宙领先。Rich Cook</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>KAFKA运维总结</title>
    <url>/2018/05/10/kafka%E8%BF%90%E7%BB%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-自身日志量过大的问题"><a href="#1-自身日志量过大的问题" class="headerlink" title="1.自身日志量过大的问题"></a>1.自身日志量过大的问题</h1><p>kafka运行一段时间之后，会发现它的主机磁盘使用率在缓慢增长，查看数据日志的持有量还是之前设置的阈值。<br><img src="/2018/05/10/kafka运维总结/1.png" alt="这里写图片描述"><br>这时候其实是kafka自身的日志打印撑爆磁盘。<br>默认的<code>~/kafka_2.11-0.9.0.0/config/log4j.properties</code>如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout </span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line">log4j.appender.kafkaAppender=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.kafkaAppender.DatePattern=&apos;.&apos;yyyy-MM-dd-HH</span><br><span class="line">log4j.appender.kafkaAppender.File=$&#123;kafka.logs.dir&#125;/server.log</span><br><span class="line">log4j.appender.kafkaAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.kafkaAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>可以看到它自身日志是按照小时去备份的，而且没有自动清除的功能，所以自身日志一直没有清掉，就可能会影响到对数据量的预估和判断。这时候我们只想保留最近n天的日志。log4j并没有配置这样的功能，在不改动源码的情况下，有两种办法达到目的。<br>​    1. 写一个crontab的脚本自动清除；<br>​    2. 修改log4j.properties，按照大小去自动清除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout </span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line">log4j.appender.kafkaAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.kafkaAppender.append=true</span><br><span class="line">log4j.appender.kafkaAppender.maxBackupIndex=2</span><br><span class="line">log4j.appender.kafkaAppender.maxFileSize=5MB</span><br><span class="line">log4j.appender.kafkaAppender.File=$&#123;kafka.logs.dir&#125;/server.log</span><br><span class="line">log4j.appender.kafkaAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.kafkaAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如上，我本人在生产环境设置的是日志备份两个，5MB就开始回滚。</p>
<h1 id="log-retention-bytes是partition级别的"><a href="#log-retention-bytes是partition级别的" class="headerlink" title="log.retention.bytes是partition级别的"></a>log.retention.bytes是partition级别的</h1><p>官网的解释是：The maximum size of the log before deleting it，解释得不清楚，实际上这个值<strong>只是partition日志的大小</strong>，不是topic的日志大小。</p>
<h1 id="log-segment-delete-delay-ms设置"><a href="#log-segment-delete-delay-ms设置" class="headerlink" title="log.segment.delete.delay.ms设置"></a>log.segment.delete.delay.ms设置</h1><p>The amount of time to wait before deleting a file from the filesystem。</p>
<p>这个值默认的是:60000ms,也就是数据量达到设定的阈值之后，还是会保留数据，等待一段时间之后才会从文件系统上删除，所以做性能测试的时候，如果数据发送速率很大，那么就会导致监控数据文件夹的时候发现它总是超出阈值才删除，可以把这个阈值设置小一点。</p>
<blockquote>
<p>怎么做对是科学，怎么做好则是艺术。——王小波</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Pipeline简介</title>
    <url>/2019/09/28/redis-pipeline/</url>
    <content><![CDATA[<h1 id="Redis-pipeline解决的问题"><a href="#Redis-pipeline解决的问题" class="headerlink" title="Redis pipeline解决的问题"></a>Redis pipeline解决的问题</h1><p>Redis本身是基于Request/Response协议的，正常情况下，客户端发送一个命令，等待Redis应答，Redis在接收到命令，处理后应答。在这种情况下，如果同时需要执行大量的命令，那就是等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁的调用系统IO。</p><a id="more"></a>
<p><img src="/2019/09/28/redis-pipeline/1.png" alt></p>
<p>为了提升效率，这时候Pipeline出现了，它允许客户端可以一次发送多条命令，而不等待上一条命令执行的结果，<strong>不仅减少了RTT，同时也减少了IO调用次数（IO调用涉及到用户态到内核态之间的切换）</strong>。</p>
<p><img src="/2019/09/28/redis-pipeline/2.png" alt></p>
<h1 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h1><ul>
<li>减少往返的时间</li>
<li>减少IO系统调用。一个read系统调用，需要从用户态，切换到内核态。</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>要支持Pipeline，其实既要服务端的支持，也要客户端支持。对于服务端来说，所需要的是能够处理一个客户端通过同一个TCP连接发来的多个命令，可以理解为，这里将多个命令切分，和处理单个命令一样（之前老生常谈的黏包现象），Redis就是这样处理的。而客户端，则是要将多个命令缓存起来，缓冲区满了就发送，然后再写缓冲，最后才处理Redis的应答，如Jedis。</p>
<p>源码层面是用一个<strong>队列</strong>去实现的。</p>
<p>在内部使用的是Jedis，JedisCluster不支持集群模式。发过去Jedis客户端之后先做Slot的计算，然后再group的发到每一个Slot。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>为什么Event-Cooking拉取kafka要使用Batch拉取的模式？是为了方便写的时候使用。</li>
</ul>
<p><img src="/2019/09/28/redis-pipeline/redis_pipeline.png" alt></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>一次打款速度优化</title>
    <url>/2019/09/15/%E4%B8%80%E6%AC%A1%E6%89%93%E6%AC%BE%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>先简单介绍下业务背景，以便看到该文章的读者碰到类似的问题，有一些解决问题思路的启发。在我们的广告业务系统中，结算和打款是解耦开的，用户的收益分天计算后打给用户。</p><p><img src="/2019/09/15/一次打款速度优化/%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="数据流"></p><p>面临的问题有两点：</p><ul>
<li>打款时段是集中的，会在瞬间产生高QPS的数据，需要控制速度不能太快，太快会对支付中台造成冲击；</li>
<li>打款能接受延时，但是也不能太慢，用户需要看到他的收益到账；</li>
</ul><a id="more"></a>



<p>那么打款模块面临最关键的问题是：<strong>可以根据处理能力掌控队列的消费速度。</strong></p>
<p>这里有一个速度不匹配的问题，队列的消费速度<strong>远大于</strong>下游<strong>支付中台</strong>可接受的QPS速度。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>在该问题中，对队列中的数据处理不要求顺序，所以我们可以用多线程来<strong>加速</strong>处理。把每次消费队列得到的数据扔到线程池里面。</p>
<p><img src="/2019/09/15/一次打款速度优化/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F.png" alt="线程池加速"></p>
<p>线程池有三个核心参数：</p>
<ul>
<li>corePoolSize。 核心线程数；</li>
<li>maximumPoolSize。最大线程数；</li>
<li>workQueue。线程池队列；</li>
</ul>
<p>打款需要<strong>控制速度</strong>，我们很容易想到控制核心线程数和最大线程数来控制速度。如果消费队列线程扔过来的消息过多，我们直接扔到workQueue里面即可，但是这样会导致<strong>线程池队列无限增长，爆掉内存</strong>。这里就需要有一种机制从线程池去告诉消费队列线程：你扔过来的消息我都处理不了了。很容易想到的方法就是：<strong>阻塞</strong>消费队列线程。</p>
<p>至此，总结一下思路。通过控制核心线程数、最大线程数来控制速度，通过线程池队列大小来防止内存爆掉，通过阻塞消费队列线程来控制消息到队列的速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(CORE_THREAD,</span><br><span class="line">     MAX_THREAD_COUNT, KEEP_ALIVE_TIMEOUT, SECONDS,</span><br><span class="line">     <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(QUEUE_SIZE),</span><br><span class="line">     <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"BatchConsumer"</span>).build(),</span><br><span class="line">     (r, executor) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果线程池队列满了, 这里用put方法阻塞住.</span></span><br><span class="line">                 executor.getQueue().put(r);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>这里用一个<strong>有界阻塞队列</strong>作为线程池队列。当线程池队列满了的时候，线程池拒绝策略不是直接扔掉消息，而是阻塞发消息的线程。</p>
<h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>如果你的业务要求消息<strong>顺序处理</strong>，那么则不能使用该方法。要求顺序处理，又想要借助多线程加速处理，下次笔者再写一篇文章谈一下我的实现方法。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>代码原型已经放到github:  <a href="https://github.com/acpipe/rigel-infra/tree/master/src/main/java/com/rigel/concurrent/speedcontrol" target="_blank" rel="noopener">控制队列消费速度</a>, FYI.</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要用自增主键</title>
    <url>/2018/09/14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<h1 id="拥抱变化"><a href="#拥抱变化" class="headerlink" title="拥抱变化"></a>拥抱变化</h1><p>关于这个topic，在网上搜索出来的，很多你可以看到这么一句话：</p><blockquote>
<p>在设计数据库时不需要费尽心思去考虑设置哪个字段为主键。</p>
</blockquote><p>这固然没错，但是不那么具有说服力。最近在做商业账号的项目的时候，对这点体会尤为深刻。我觉得设置自增主键的最主要目的是：<strong>应对变化</strong>。</p><p>笔者遇到的场景为：维护商业账号的资质相关信息。账号是由全局唯一且自增的分布式ID生成器生成的，很显然这个时候我们把账号作为主键这就天然合理。于是，初版建表的时候就有了如下表结构:</p><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accountId // 账号ID,全局唯一</span><br><span class="line">cert // 该账号的资质</span><br><span class="line">review_detail // 该账号的审核详情</span><br><span class="line">cert_photo // 资质的图片</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当时业务迭代一定时间之后，新的需求来了：一个账号，在不同业务线，需要享有不同资质。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accountId // 账号ID,全局唯一</span><br><span class="line">business // 新加入的字段，标志不同业务线.</span><br><span class="line">cert // 该账号的资质</span><br><span class="line">review_detail // 该账号的审核详情</span><br><span class="line">cert_photo // 资质的图片</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个时候就accountId就不是一个唯一的了，因为，同一个账号，不同业务线，资质是不一样的。</p>
<p>笔者和同事讨论之后，做出如下方案：</p>
<ol>
<li>先把原来业务代码中依赖主键查询的代码做升级；</li>
<li>把数据库原来的索引drop掉；</li>
<li>新建自增主键索引；</li>
<li>升级当前业务，实现同一账号，不同系统，享有不同资质；</li>
</ol>
<blockquote>
<p>但是第二步之后，实际上drop掉主键，这个时候Mysql是没有主键状态的。如果没有定义主键，则会使用非空的UNIQUE键做主键 ; 如果没有非空的UNIQUE键，则系统生成一个6字节的rowid做主键</p>
</blockquote>
<p>这么做其实可能会有性能问题。</p>
<p>如果我们一开始设计表的时候，就用业务无关的ID作为自增主键，那么本次升级就不会变得这么麻烦。推荐的做法是，在系统设计之初：</p>
<ol>
<li>设置自增主键；</li>
<li>把当前需要约束的键（这里即账号ID）作为唯一键约束;</li>
</ol>
<blockquote>
<p>主键:<br>1.可以定义一列或多列为主键。不允许空（NULL）,主健可作外健，唯一索引不可；<br>2.定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。</p>
<p>唯一键：<br>1.唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，<br>指定列上都不允许有相同的值，允许空（NULL）<br>2.唯一约束可以用于保证在基表中增加一条记录时，一个或多个列值是唯一的。</p>
</blockquote>
<h1 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h1><ol>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，学过数据结构的同学都知道，在中间插入，B+树为了维持平衡，引起B+树的节点分裂。 总的来说用自增主键是可以提高查询和插入的性能。</li>
<li>在切换这段时间，如果你的系统对latency非常敏感，那么就不能这么简单的做了，可能需要重新备份数据库，由于笔者维护这个表是B端系统，且数据量级大概百万量级，这么搞是OK的。</li>
<li>自增ID可以用来做分页优化。当然这是另一个话题了，下次分析。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>交替打印出奇偶数</title>
    <url>/2019/09/16/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%87%BAAB/</url>
    <content><![CDATA[<p>中秋佳节放假前夕，同事无心工作，聊到大家面试候选人的题目，其中提到如何用两个线程交替打印出奇偶数。百无聊赖之际，索性写了一下code。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>两个线程交替打印奇数和偶数，最关键的是如何协作的问题。</p><ul>
<li>打印的数可以用java里面的<code>atomicInteger</code> 来保证原子性；</li>
<li>打印何时结束需要设置一个上限，比如打印到100结束；</li>
</ul><a id="more"></a>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintABAtomic</span> <span class="keyword">implements</span> <span class="title">IPrintAB</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印何时结束需要设置一个上限，打印到100结束；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRINT_NUM = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomicInteger.get() &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="comment">// 打印奇数.</span></span><br><span class="line">                <span class="keyword">if</span> (atomicInteger.get() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + atomicInteger.get());</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomicInteger.get() &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="comment">// 打印偶数.</span></span><br><span class="line">                <span class="keyword">if</span> (atomicInteger.get() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + atomicInteger.get());</span><br><span class="line">                    atomicInteger.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以采用另一种办法。用<code>volatile</code> 的方式来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintABVolatile</span> <span class="keyword">implements</span> <span class="title">IPrintAB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRINT_NUM = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="junit多线程的坑"><a href="#junit多线程的坑" class="headerlink" title="junit多线程的坑"></a>junit多线程的坑</h1><p>如果你用单元测试该代码会发现一个问题：还没打印到100线程就结束了。junit日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[INFO  2019-09-21 09:20:44.279] [main] org.springframework.test.context.support.AbstractTestContextBootstrapper.getTestExecutionListeners(AbstractTestContextBootstrapper.java:187) [Using TestExecutionListeners: [org.springframework.test.context.web.ServletTestExecutionListener@694abbdc, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@2e005c4b, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@4567f35d, org.springframework.test.context.support.DirtiesContextTestExecutionListener@5ffead27, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverTestExecutionListener@6356695f, org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener@4f18837a, org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener@359f7cdf, org.springframework.boot.test.autoconfigure.restdocs.RestDocsTestExecutionListener@1fa268de, org.springframework.boot.test.autoconfigure.web.client.MockRestServiceServerResetTestExecutionListener@4f6ee6e4, org.springframework.boot.test.autoconfigure.web.servlet.MockMvcPrintOnlyOnFailureTestExecutionListener@4466af20]][INFO  2019-09-21 09:20:44.380] [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:317) [Loading XML bean definitions from class path resource [applicationContext.xml]]</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.668</span>] [main] org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:<span class="number">583</span>) [Refreshing org.springframework.context.support.GenericApplicationContext@<span class="number">34</span>a3d150: startup date [Sat Sep <span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44</span> CST <span class="number">2019</span>]; root of context hierarchy]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.946</span>] [Thread-<span class="number">2</span>] com.rigel.concurrent.printab.PrintABVolatile.lambda$printAB$<span class="number">0</span>(PrintABVolatile.java:<span class="number">27</span>) [num:<span class="number">30</span>]</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.947</span>] [Thread-<span class="number">3</span>] com.rigel.concurrent.printab.PrintABVolatile.lambda$printAB$<span class="number">1</span>(PrintABVolatile.java:<span class="number">37</span>) [num:<span class="number">31</span>]</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.947</span>] [Thread-<span class="number">2</span>] com.rigel.concurrent.printab.PrintABVolatile.lambda$printAB$<span class="number">0</span>(PrintABVolatile.java:<span class="number">27</span>) [num:<span class="number">32</span>]</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.947</span>] [Thread-<span class="number">3</span>] com.rigel.concurrent.printab.PrintABVolatile.lambda$printAB$<span class="number">1</span>(PrintABVolatile.java:<span class="number">37</span>) [num:<span class="number">33</span>]</span><br><span class="line">[INFO  <span class="number">2019</span>-<span class="number">09</span>-<span class="number">21</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">44.948</span>] [Thread-<span class="number">2</span>] com.rigel.concurrent.printab.PrintABVolatile.lambda$printAB$<span class="number">0</span>(PrintABVolatile.java:<span class="number">27</span>) [num:<span class="number">34</span>]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个进程中有三个线程，分别是：<code>thread-main</code>、<code>thread-2</code>、<code>thread-3</code>。但是当打印到第34个数字的时候，这个进程就退出了。</p>
<p>为了一探究竟，看了一下<code>TestRunner</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestRunner aTestRunner = <span class="keyword">new</span> TestRunner();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TestResult r = aTestRunner.start(args);</span><br><span class="line">            <span class="keyword">if</span> (!r.wasSuccessful()) &#123;</span><br><span class="line">                <span class="comment">// 执行成功不成功.</span></span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            System.err.println(var3.getMessage());</span><br><span class="line">            System.exit(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestResult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">wasSuccessful</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.failureCount() == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.errorCount() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程main执行结束后，会直接调用<code>wasSuccessful</code> 方法，判断返回<code>true</code>，<code>System.exit(0)</code> 直接将虚拟机结束掉。至此原因探究清楚了，提供几种简单的解法。</p>
<h1 id="junit-多线程问题解决"><a href="#junit-多线程问题解决" class="headerlink" title="junit 多线程问题解决"></a>junit 多线程问题解决</h1><h2 id="使用CountDownLatch"><a href="#使用CountDownLatch" class="headerlink" title="使用CountDownLatch"></a>使用CountDownLatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintABVolatile</span> <span class="keyword">implements</span> <span class="title">IPrintAB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRINT_NUM = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 偶数线程执行完则计数器减一</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; MAX_PRINT_NUM) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"num:"</span> + count);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 奇数线程执行完则计数器减一</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicInteger</code>的方法类似，在此不做赘述。</p>
<h2 id="直接用main方法调试"><a href="#直接用main方法调试" class="headerlink" title="直接用main方法调试"></a>直接用main方法调试</h2><p>当然，这种方法仅用于调试，不能用于写单元测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     PrintABVolatile printABVolatile = <span class="keyword">new</span> PrintABVolatile();</span><br><span class="line">     printABVolatile.printAB();</span><br><span class="line">     <span class="comment">// main线程执行完会等待其他线程执行完，这个进程才会退出.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文是一道经典的面试题，主要考察多线程之间的协调工作，提供了两种方法，分别利用<code>volatile</code>的可见性和<code>AtomicInteger</code> 的原子性对两个线程进行协调。在实践过程中，遇到junit不支持多线程的坑，可以使用<code>CountDownLatch</code> 来等待两个奇偶线程结束后再结束，这里可以考察候选人对于线程结束的理解。</p>
<p>实现源码见:<a href="https://github.com/acpipe/rigel-infra/blob/master/src/main/java/com/rigel/concurrent/printab/PrintABAtomic.java" target="_blank" rel="noopener">交替打印AB</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/2019/09/28/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<p>决策树是一类机器学习算法，执行过程很容易理解，这里不做赘述。决策树(上)主要关注如何创建决策树，其中涉及到一些信息论的基本概念的理解，并编码实现。决策树的剪枝放在决策树(下)。</p><p>要构建决策树关键就是划分的选择。这里涉及到6个概念，分别是：</p><ul>
<li>信息熵(information entropy)</li>
<li>条件信息熵(conditional information entropy)</li>
<li>信息增益(information gain)</li>
<li>信息增益率(information gain perent)</li>
<li>基尼系数(gini index)</li>
<li>基尼值</li>
</ul><a id="more"></a>


<h1 id="熵和信息增益"><a href="#熵和信息增益" class="headerlink" title="熵和信息增益"></a>熵和信息增益</h1><p>要选择用哪个特征进行决策树划分。我们可以这么思考问题：决策树划分的目的就是通过划分把相同label的数据放到一起，不同的label我们可以理解为 <strong>数据混乱程度</strong>，划分的目的就是<strong>减少数据的混乱程度</strong>。选择每一个feature进行划分都可以减少数据混乱，我们选择减少混乱程度最大的 那个可以更快的达到目的。怎么知道选择哪个feature进行划分减少的混乱程度最大，我们考察<strong>划分之后的数据混乱程度</strong> ，划分之后混乱程度越小，我们就选择谁进行划分。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th align="left">类比</th>
<th>定义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>信息熵</td>
<td align="left">数据混乱程度</td>
<td>随机变量的不确定性</td>
<td>随机变量不确定性越大、数据混乱程度越大、信息熵越高</td>
</tr>
<tr>
<td>信息增益</td>
<td align="left">减少的数据混乱程度</td>
<td>不确定性的减少程度</td>
<td>减少程度越大、信息增益越大</td>
</tr>
<tr>
<td>条件信息熵</td>
<td align="left">经过某一个划分后数据的混乱程度</td>
<td>在某个条件下的不确定性的减少程度</td>
<td>信息增益=信息熵 -条件信息熵</td>
</tr>
</tbody></table>
<p>信息熵定义: $ H(X)=- \sum_{i}^{|labels|}p(x{i})\log_{2}p(x{i}) $ ,为什么这么定义可以参考:<a href="https://www.zhihu.com/question/30828247" target="_blank" rel="noopener">为什么信息熵要定义成-Σp*log(p)？</a></p>
<p>条件信息熵定义:  $ {\displaystyle \mathrm {H} (X|Y)=-\sum <em>{i,j}p(x</em>{i},y_{j})\log_{2} {\frac {p(x_{i},y_{j})}{p(y_{j})}}} $</p>
<p>信息增益=信息熵 - 条件信息熵</p>
<p>为方便理解，我们用一组数据来模拟这个过程。</p>
<p><img src="/2019/09/28/决策树/data.png" alt></p>
<p>因为是二分类问题，|labels| = 2, </p>
<p>划分前的信息熵为: $ Ent(D) = - \sum_{i}^{2}p_{i}log_{2}p_{i}=-({\frac{8}{17}}log_{2}{\frac{8}{17}}+{\frac{9}{17}}log_{2}{\frac{9}{17}}) $</p>
<p>以”色泽”划分为例，划分为三个节点：青绿、乌黑、浅白。每个节点计算条件信息熵为：</p>
<p><img src="/2019/09/28/决策树/2.png" alt></p>
<p>$ Ent(D_{色泽})  = -({\frac{3}{6}}log_{2}{\frac{3}{6}}+{\frac{3}{6}}log_{2}{\frac{3}{6}}) $</p>
<p>$ Ent(D_ {乌黑})  = -({\frac{4}{6}}log_{2}{\frac{4}{6}}+{\frac{2}{6}}log_{2}{\frac{2}{6}}) $</p>
<p>$ Ent(D_ {浅白})  = -({\frac{1}{5}}log_{2}{\frac{1}{5}}+{\frac{4}{5}}log_{2}{\frac{4}{5}}) $</p>
<p>$  IG(色泽) = 划分前的信息熵 - 划分后的信息熵 $</p>
<p>$ = Ent(D) - \sum( 每个节点的权重 * 该节点的信息熵) $</p>
<p>$= Ent(D) - \sum <em>{v=1}^{划分后的节点个数} \frac{|D</em>{v}|}{|D|}Ent(D_{v}) $</p>
<p>$ = \frac{6}{17} Ent(D_{乌黑})  + \frac{6}{17} Ent(D_{青绿}) + \frac{5}{17} Ent(D_{浅白})$</p>
<p>同理可以求出IG(根缔)、IG(敲声)…，选取信息增益最大的，即可最大限度的减少划分前的数据混乱程度，作为决策树的划分条件，递归的对每一个节点进行划分就可以构建决策树了。ID3算法就是选取信息增益最大的属性作为划分的。</p>
<p>下面我们编码实现这一过程，毕竟原理搞懂了，谁简历上不是精通C++、python、java等多门编程语言呢，见<a href="https://github.com/Acceml/machine_learning" target="_blank" rel="noopener">github</a>…</p>
<h1 id="信息增益率-information-gain-perent"><a href="#信息增益率-information-gain-perent" class="headerlink" title="信息增益率(information gain perent)"></a>信息增益率(information gain perent)</h1><p>在对上面数据的模拟过程中，如果我们用编号属性进行划分，$ Ent(D_{1})$、$ Ent(D_{2})$… 都是 0，GI(编号)=Ent(D)，是所有属性中信息增益最大的，因为划分后直接把信息混乱程度降为0了，但是这样的决策树并不具有<strong>泛化能力</strong>。</p>
<p>$GainRatio(D, a) = \frac{Gain(D,a)}{IV(a)} $</p>
<p>其中IV叫做属性a的故有值，定义如下:</p>
<p>$IV(a) =- \sum_{v=1}^{V}\frac{|D_{v}|}{|D|}log_{2}{\frac{|D_{v}|}{|D|}}$</p>
<p>其中v是划分后的取值，取值数目越多，IV越大，增益率就越小。</p>
<h1 id="基尼系数-gini-index"><a href="#基尼系数-gini-index" class="headerlink" title="基尼系数(gini index)"></a>基尼系数(gini index)</h1><p>基尼系数较为简单，它表示：从数据集中随机抽取两个样本，label不一样的概率。</p>
<p>基尼值：$Gini(D_{v}) = 1-\sum_{k=1}^{2}p_{k}^2$</p>
<p>每个节点的基尼系数加一个权重，就得到基尼系数的定义。</p>
<p>基尼系数：$GiniIndex(D, a) = \sum_{v=1}^{V}\frac{|D_{v}|}{|D|}Gini(D_{v})$</p>
<p>选取划分之后基尼系数最小的属性作为最优划分属性，基尼系数越小，那么数据混乱的程度越小。</p>
<h1 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h1><p>总结一下几种决策树算法的划分准则。</p>
<ul>
<li>ID3 — <strong>信息增益</strong> <strong>最大</strong>的准则</li>
<li>C4.5 — <strong>信息增益比最大</strong>的准则</li>
<li>CART<ul>
<li>回归树: <strong>平方误差</strong> <strong>最小</strong> 的准则</li>
<li>分类树: <strong>基尼系数</strong> <strong>最小</strong>的准则</li>
</ul>
</li>
</ul>
<h1 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h1><h2 id="为什么剪枝"><a href="#为什么剪枝" class="headerlink" title="为什么剪枝"></a>为什么剪枝</h2><p>剪枝是为了防止过拟合，增加决策树的泛化能力。</p>
<h2 id="剪枝-的方法"><a href="#剪枝-的方法" class="headerlink" title="剪枝 的方法"></a>剪枝 的方法</h2><p>采用留出法，一部分sample用于生成决策树（训练集），另一部分样本用来检测决策树的泛化能力（验证集）。泛化能力怎么衡量呢?就是划分前后正确率。</p>
<table>
<thead>
<tr>
<th>剪枝方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>预剪枝</td>
<td>减小过拟合</td>
<td>可能会欠拟合(基于贪心思想，某次划分不能提升泛化就认为之后的划分不能提升泛化能力)</td>
</tr>
<tr>
<td>后剪枝</td>
<td>减小过拟合，一般也不会欠拟合</td>
<td>存储大</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)" target="_blank" rel="noopener">维基百科</a></li>
<li>《机器学习》(周志华)</li>
<li><a href="https://www.zhihu.com/question/30828247" target="_blank" rel="noopener">为什么信息熵要定义成-Σp*log(p)？</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表实践</title>
    <url>/2019/09/28/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近的一个项目是解决Mysql的一个表容量问题，做了一次分表实践，期间参看了很多方案，但是通篇看下来，很多都是讲怎么做的，方法论层面较为缺少；有的则细节总结不到位，比如说分库分表有哪些坑，需要考虑什么问题，并没有说清楚。故该篇文章作为分库分表实践的自我总结，以便以后遇到类似问题，迅速定位找到合适的解法。如果能给您带来些许参考，那将是莫大的荣幸。</p><a id="more"></a>
<h1 id="你真的需要分库分表吗"><a href="#你真的需要分库分表吗" class="headerlink" title="你真的需要分库分表吗"></a>你真的需要分库分表吗</h1><p>在做分库分表之前，请明确的描述清楚你的问题。这个描述的过程不应该是定性的，而是<strong>定量的、边界可衡量</strong>的。例如：由于xxx业务的日益增长，遇到了性能问题，需要分库分表。这样的描述就极其模糊。正确的定义问题边界是：由于xxx业务增长，某个接口延时耗时增加多少，某平台因为数据库查询慢导致可用性降低多少。而关于定于问题，笔者认为最重要的是定义清楚两个问题：</p>
<ol>
<li><strong>当前系统遇到什么问题</strong>。即当前系统遇到的性能、容量等问题，定量定义；</li>
<li><strong>希望通过该次升级支持多久</strong>。并不是从当前看，系统设计得越好，就能支撑业务发展很好，对未知需要保持敬畏，避免过度设计。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2017/06/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>这应该是所有设计模式中最简单的设计模式了，所以从它讲起。</p><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>用来创建独一无二对象。确保只有一个实例，并且提供一个全局访问点(getSingleton)。</p><h1 id="v0-0-1-简单实现"><a href="#v0-0-1-简单实现" class="headerlink" title="v0.0.1-简单实现"></a>v0.0.1-简单实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Acceml on 2016/5/28.</span></span><br><span class="line"><span class="comment"> * Email: huminghit@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;<span class="comment">//risk</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>要注意的点是：</p>
<ul>
<li>单例模式没有public的construct</li>
<li>有一个静态的对象，每次getSingleton()的时候获得的是同一个</li>
</ul>
<p>这样写的问题是：<br>多线程的时候回出问题，比如我们有两个线程thread0，thread1去同时调用getSingleton()这个方法，就会在if(singleton == null)出现问题。thread0,thread1都认为没有该判断为true，就会去创建两个对象，没有多线程的时候，这样使用没有问题。</p>
<h1 id="V0-0-2-双重锁实现"><a href="#V0-0-2-双重锁实现" class="headerlink" title="V0.0.2-双重锁实现"></a>V0.0.2-双重锁实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Acceml on 2016/5/28.</span></span><br><span class="line"><span class="comment"> * Email: huminghit@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;<span class="comment">//判断1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;<span class="comment">//判断2</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变化有：</p>
<ul>
<li>加了volatile关键字</li>
<li>加了双重锁<br>加volatile很容易理解，因为加上该关键字，那么变量就对不同线程可见。在方法getSingleton()中，第一个判断不存在，就进入同步块，进入同步块之后再判断一次，还是为null才创建实例。但是为什么这么做呢？假如thread0执行到判断1，它进入同步区之后，thread2就进不来了，从而保证只有一个线程执行到判断2。</li>
</ul>
<h1 id="v0-0-3-eager实现"><a href="#v0-0-3-eager实现" class="headerlink" title="v0.0.3-eager实现"></a>v0.0.3-eager实现</h1><p>上面两种方法都是我们需要的时候去做判断，然后实例化，如果创建对象负担不重的话，可以考虑在静态初始化的时候创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Acceml on 2016/5/28.</span></span><br><span class="line"><span class="comment"> * Email: huminghit@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>97% 的情况下，过早优化是万恶之源，然而我们也不该放弃 3% 的关键机会。  —— Donald Knuth</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好的design</title>
    <url>/2017/11/10/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9A%84design/</url>
    <content><![CDATA[<p>要做大型分布式系统设计，最重要的事情是：把你所做的事情清楚、准确的描述出来。通常在进行大型分布式系统设计的时候都要进行design review，这个过程需要保证你的设计和别人理解你的设计尽量少的出现偏差。笔者参与或主导设计过三个大型的模块：</p><ol>
<li>DAL(Data Access Layer)。该系统封装数据库的结构，解耦数据库和服务模块。</li>
<li>离线数据更新系统。把离线算法模型更新到线上，供线上服务使用，实现数据版本化、回滚和监控。</li>
<li>广告索引系统。该系统实现广告数据的增量更新和广告定向信息索引更新（正在参与设计中）</li>
</ol><a id="more"></a>

<p>就这些模块总结一些设计系统的方法论和套路。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>高考写作文的时候，老师都非常讨厌模板，但是我这里还是推荐按照固定的套路，这样可以方便的讲清楚问题。</p>
<ul>
<li><p>简介（描述为什么做，解决什么问题）</p>
<ul>
<li>背景。面临的问题是什么，使用该系统后会变成什么样子。</li>
<li>Goal。进度和人日预估，版本功能点和时间节点。</li>
<li>术语。该系统中特有的词汇，但是不要把大家认为common sence的东西写进去。</li>
<li>参考资料</li>
</ul>
</li>
<li><p>总体设计</p>
<ul>
<li>规约。描述好该系统解决问题的边界是什么？可以承载多大的并发，多少数据，数据更新频率。</li>
<li>系统结构图(系统间)。该系统和其他系统的交互关系。</li>
<li>模块图(系统内)。该系统分为几个模块，同时要给出：图例、数据流向、数据模块、功能模块。</li>
</ul>
</li>
<li><p>功能模块1。</p>
<ul>
<li>功能描述。描述好功能、每个功能点面向谁、交互的模块是什么、数据流向。</li>
<li>API定义。描述好API的功能、同步还是异步、阻塞还是非阻塞。</li>
<li>关键点。如果涉及到分布式锁、一致性等对于该模块比较重要的点需要单独说一下。</li>
<li>示意图。如果面向的是用户，可以适当给出示意图。</li>
<li>可用性。</li>
</ul>
</li>
<li><p>功能模块X</p>
</li>
<li><p>数据模块1。</p>
<ul>
<li>表设计。需要详细描述数据库表，包括字段的类型、含义、更新频率等信息。</li>
<li>数据一致性保证、完整性。</li>
</ul>
</li>
<li><p>数据模块X。</p>
</li>
<li><p>关键流程(功能)说明</p>
<ul>
<li>该模块用于主要的功能点说明。比如你设计的是外卖订单系统，那么下单，退单，结算等就显得尤为重要。</li>
<li>这个部分可能需要画泳道图、或者跨职能流程图，角色就是上面定义的各模块。</li>
<li>异常。如果关键步骤失败了，会出现什么情况，系统对该情况的容忍度。</li>
</ul>
</li>
</ul>
<ul>
<li>可用性说明<ul>
<li>如果某个模块挂掉，或者该系统的某个子系统挂掉会出现什么情况，需要详细给出系统的可用性并有后续的action跟踪。</li>
</ul>
</li>
</ul>
<ul>
<li>监控报警集成<ul>
<li>需要集成哪些监控项和报警项。</li>
</ul>
</li>
</ul>
<ul>
<li>环境要求<ul>
<li>描述JDK、ZK、thrift、dubbo、mysql等。如果部门都是统一的，该章节可以省略。</li>
</ul>
</li>
</ul>
<p>当然，以上的只是给出一个套路，具体看系统的侧重点，每个系统对外部服务可用性、基础服务可用性的依赖都是不一样的。本文提供一个基本的框架，这样做design的时候会比较有条理。</p>
<h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p>可以看到，要想准确无误的传达信息，最重要的两个图：<strong>系统结构图(系统间)和模块图(系统内)</strong>。这两个图直接决定了你整个design的走向，是做成一个服务还是做成一个jar包，是同步还是异步等等。 如果拿捏不定，需要自己列出类似于决策平衡单的东西。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>方案1</th>
<th>方案2</th>
<th align="left">方案3</th>
</tr>
</thead>
<tbody><tr>
<td>系统结构图</td>
<td></td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td>模块框图</td>
<td></td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td>优点</td>
<td></td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td>缺点</td>
<td></td>
<td></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>该图列出后，系统设计主笔者需要给出推荐理由，并做一些取舍，作为设计初稿可以给组内review或者组织brain storm ，最终拍板形成最终设计方案。刚毕业的同学这个部分很难，通常需要自己调研业界已有方案，和自己的业务痛点和场景做对比，然后提出上面的对比方案，组织一个brain storm，把大家的的idea记下来之后，会有新的idea。</p>
<h1 id="Diss-自己"><a href="#Diss-自己" class="headerlink" title="Diss 自己"></a>Diss 自己</h1><p>自己设计的系统就是要不断的和自己的idea做斗争，最终得出一个相对优化或者折中的设计。要把自己想象成被challenge的对象，在做一个系统的时候怎么去challenge自己呢?尤其是在没有经验的时候，自己想的时候觉得自己很完美，结果别人挑出一堆毛病没办法解决。我自己总结了一些常规的点如下：</p>
<ul>
<li>系统或者子系统挂掉。任意一个节点挂掉系统的可用性，自己随便想想挂掉个几个模块，宕机几台机子。</li>
<li>数据的一致性。</li>
<li>不同节点之间会不会存在竞争共享锁。</li>
<li>数据的完整性。</li>
<li>系统调用超时。</li>
<li>该系统发生状态变化时候，对线上系统其他系统的影响。</li>
<li>如果是服务，什么时候需要熔断，什么时候进行服务降级。</li>
<li>用户异常行为。</li>
<li>技术实现难度。这个需要自己对细节和不可控部分有认识，不然很容易画大饼，避免的办法是多交流。</li>
<li>启动速度，回滚速度，响应速度。</li>
<li>什么时候触发监控，报警频率和量级会不会对其他系统构成挑战。</li>
<li>进度预估是否合理。</li>
<li>数据库容量会不会爆炸增长，尤其是异常的时候。</li>
<li>系统瓶颈在哪里。比如索引系统的瓶颈在于更新索引，状态是否一致。</li>
<li>系统迭代更新时可用性。</li>
<li>系统的边界界定是否合理。比如该系统解决的问题是不是还可以扩大一点，涵盖的业务是不是可以更多。</li>
<li>是不是可以复用已有模块避免重复造轮子。</li>
</ul>
<p>Diss自己还需要整个复盘交互的细节，通常会发现很多问题自己没有考虑到。</p>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>通常Diss完自己后，根据别人的意见修改，还需要check一下一些细节，这个部分很多人不注意。</p>
<ul>
<li>图例。图例其实很有用，尤其是系统稍微复杂一点。比如：数据模块、中间件、功能模块、元数据流、主数据流。不写图例让人觉得很混乱。</li>
<li>数据规约的大小是不是合适。比如你随便定一个只支持500M的数据更新，有没有数据支持。</li>
<li>模块颜色。通常系统设计都需要分层，尽量用不同颜色标志，如接入层、转发层、业务层、数据层等。但是颜色不要太浮夸，毕竟程序员是需要低调一点的。</li>
</ul>
<p><img src="/2017/11/10/如何做好的design/HIT.jpg" alt="哈工大校训"></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器分类</title>
    <url>/2019/09/28/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>为什么会有那么多垃圾收集器?因为根据对象的特点，例如对象的生命周期、大小，进行分代以后有不同的垃圾回收算法，每种算法的具体实现和侧重点不同，就有众多的垃圾回收器。不存在什么优劣之分.</p><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li>
</ul><a id="more"></a>

<h1 id="吞吐量-vs-停顿时间"><a href="#吞吐量-vs-停顿时间" class="headerlink" title="吞吐量 vs 停顿时间"></a>吞吐量 vs 停顿时间</h1><p>$吞吐量 = {\frac{运行用户代码的时间}{运行用户代码时间+垃圾回收时间}}$</p>
<p>eg: 虚拟机总共运行了100min，垃圾回收花掉1min, 吞吐量为：99%</p>
<p><strong>停顿时间缩短是以牺牲吞吐量和新生代空间为代价的</strong>。</p>
<p>新生代空间缩小 -&gt; 停顿时间缩短 -&gt; GC频繁 -&gt; <strong>GC的总时间增加</strong>-&gt; 吞吐量下降 </p>
<h1 id="Serial-Garbage-Collector"><a href="#Serial-Garbage-Collector" class="headerlink" title="Serial Garbage Collector"></a>Serial Garbage Collector</h1><p><img src="/2019/09/28/垃圾回收器分类/1.png" alt></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>单线程，只会使用一个CPU，一条线程去完成垃圾回收工作</li>
<li>进行垃圾回收的时候必须要暂停所有工作线程</li>
<li>采用复制算法</li>
<li>新生代</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Client模式（分配的内存少）下不错的选择</p>
<h1 id="Parallel-Garbage-Collector"><a href="#Parallel-Garbage-Collector" class="headerlink" title="Parallel Garbage Collector"></a>Parallel Garbage Collector</h1><p><img src="/2019/09/28/垃圾回收器分类/2.png" alt></p>
<p><strong>ParNew</strong>收集器就是Serial收集器的多线程版本.</p>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>也是stop the word，只是GC的时候是多线程</li>
<li><strong>-XX:ParallerGCThreads</strong>可以设置线程数目，默认是CPU的数目。</li>
<li>采用复制算法</li>
<li>新生代</li>
</ul>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li>只有它可以和CMS配合</li>
<li>Server模式下的虚拟机中首选的新生代收集器</li>
</ul>
<h1 id="Parallel-Scavenge-Garbage-Collector"><a href="#Parallel-Scavenge-Garbage-Collector" class="headerlink" title="Parallel Scavenge Garbage Collector"></a>Parallel Scavenge Garbage Collector</h1><h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>目标是达到一个可控制的 <strong>吞吐量</strong></li>
<li>老年代</li>
</ul>
<h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><ul>
<li>吞吐量高，停顿时间就长。不适合哪种需要与用户交互的程序，在后台运算不需要太多交互的任务。</li>
<li>Parallel Scavenge收集器无法与CMS收集器配合使用</li>
<li>采用复制算法</li>
</ul>
<h1 id="Serial-Old-Garbage-Collector"><a href="#Serial-Old-Garbage-Collector" class="headerlink" title="Serial Old Garbage Collector"></a>Serial Old Garbage Collector</h1><h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>Serial Old 是 Serial收集器的老年代版本</li>
<li>单线程</li>
<li>采用标记整理算法</li>
</ul>
<h2 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h2><ul>
<li>老年代</li>
</ul>
<h1 id="Parallel-Old-Garbage-Collector"><a href="#Parallel-Old-Garbage-Collector" class="headerlink" title="Parallel Old Garbage Collector"></a>Parallel Old Garbage Collector</h1><h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>多线程</li>
<li>吞吐量优先</li>
</ul>
<h2 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h2><ul>
<li>老年代</li>
</ul>
<h1 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h1><h3 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h3><ul>
<li>获取最短回收停顿时间为目标</li>
<li>标记-清除算法</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>( <strong>注意哪些阶段是停顿的</strong>)</p>
<p><img src="/2019/09/28/垃圾回收器分类/cms.png" alt></p>
<ul>
<li><strong>初始标记（CMS initial mark）</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li><strong>并发标记（CMS concurrent mark）</strong>：进行<strong>GC Roots Tracing</strong>的过程，在整个过程中耗时最长。</li>
<li><strong>重新标记（CMS remark）</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。</li>
<li><strong>并发清除（CMS concurrent sweep）</strong></li>
</ul>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul>
<li><strong>对CPU资源非常敏感</strong> 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<strong>CMS默认启动的回收线程数是（CPU数量+3）/4</strong>，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是<strong>当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大</strong>，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li>
<li><strong>无法处理浮动垃圾（Floating Garbage）</strong> 由于CMS<strong>并发清理</strong> 阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。</li>
<li><strong>标记-清除算法导致的空间碎片</strong>。</li>
</ul>
<h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><ul>
<li>老年代</li>
<li>对时间敏感的任务，比如互联网网站</li>
</ul>
<h1 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h1><p>关于G1垃圾回收器是目前生产环境用的垃圾回收器，准备用一篇文章结合GC日志进行单独讲解。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<p>tracking-service中:<code>-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</code></p>
<p>delivery-service中:<code>+UseG1GC</code></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">深入理解JVM(3)——7种垃圾收集器</a></li>
<li>周志明《深入理解java虚拟机》</li>
<li><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC的一些关键技术</a></li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式在日志系统中的运用</title>
    <url>/2017/08/14/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p> 本文旨在介绍builder设计模式的运用。适合对builder设计模式了解，但是不知道怎么运用的同学。</p>
</blockquote><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在当前笔者维护的广告系统中，有一个模块专门对接客户端上报的点击、曝光、下载事件，用于记录每个广告数据，供算法决策、BI报表展示给广告主。这些数据的格式不统一，使用的协议也不统一，有的是通过http有的是通过rpc调用。如下图所示，该模块的作用在于汇总各数据流、兼容新老数据格式。每种格式自己维护一套解析系统，我们的代码会显得十分的混乱。</p><a id="more"></a>

<h1 id="M-1结构"><a href="#M-1结构" class="headerlink" title="M-1结构"></a>M-1结构</h1><p>对于这样的<strong>M to 1</strong>的数据流，就是输入有多种格式，但是输出固定为一种格式，非常适合用builder来统一。</p>
<p><img src="/2017/08/14/建造者模式在日志系统中的运用/1.png" alt="这里写图片描述"></p>
<p>经典的builder模式伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionLog</span> </span>&#123;</span><br><span class="line">  	ActionLog()&#123;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">private</span> <span class="keyword">final</span> String requiredParams;</span><br><span class="line">      	<span class="keyword">private</span> <span class="keyword">final</span> String optionalParams;</span><br><span class="line">      	Builder(String requiredParams) &#123;</span><br><span class="line">        </span><br><span class="line">      	&#125;</span><br><span class="line">      </span><br><span class="line">     	<span class="function"><span class="keyword">public</span> Builder <span class="title">withOptionalParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	...</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="function"><span class="keyword">public</span> ActionLog <span class="title">build</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> ActionLog(<span class="keyword">this</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可参考《effective java》chapter1。这里谈一个细节，为什么这个内部静态类需要define 为final的? builder封装了构造的过程，在还没有构造完成时，允许使用提供的<code>withOptionalParams</code> 来构建对象，但是一旦这个对象确定下来，就不允许改变，得到最终想要的ActionLog。</p>
<h1 id="M-N结构"><a href="#M-N结构" class="headerlink" title="M-N结构"></a>M-N结构</h1><p>通常的业务场景都不是一种数据格式可以搞定的，可能需要生成多种数据格式。如下游需要送到kafka、hdfs、hive表、thrift调用等。构造这些格式的<code>meta data</code> 已经包含在builder中了，所以我们只需要稍加改动即可。<br><img src="/2017/08/14/建造者模式在日志系统中的运用/2.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionLog</span> </span>&#123;</span><br><span class="line">  	ActionLog()&#123;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">private</span> <span class="keyword">final</span> String requiredParams;</span><br><span class="line">      	<span class="keyword">private</span> <span class="keyword">final</span> String optionalParams;</span><br><span class="line">      	Builder(String requiredParams) &#123;</span><br><span class="line">        </span><br><span class="line">      	&#125;</span><br><span class="line">      </span><br><span class="line">     	<span class="function"><span class="keyword">public</span> Builder <span class="title">withOptionalParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	...</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="function"><span class="keyword">public</span> ActionLog <span class="title">buildForKafka</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> ActionLog(<span class="keyword">this</span>);&#125;</span><br><span class="line">      	<span class="function"><span class="keyword">public</span> ActionLog <span class="title">buildForThrift</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> ActionLog(<span class="keyword">this</span>);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多条上报"><a href="#多条上报" class="headerlink" title="多条上报"></a>多条上报</h1><p>上面的两个例子都是一个请求，产生一条日志，请求层面来说是<code>one to one</code> ，有时候客户端通常会做一个proxy或者sdk，来减少请求次数，一次上报多条。</p>
<p>这个时候请求层面属于<code>M to one</code> 的结构。我们构造出多个builder就好，不要在builder中做额外的事情，buider保持它职能的单一性。<code>one request</code>-&gt; <code>List&lt;Builder&gt;</code> -&gt; <code>List&lt;ActionLog&gt;</code></p>
<p>目前在开发中遇到这三种情况，基本可以cover到解析日志的各种情况。在大型系统中，数据结构的统一十分重要。FYI</p>
<blockquote>
<p>Don’t be evil. 不要用 eval()。—— Google</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式使用的小技巧</title>
    <url>/2018/09/14/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="什么时候用策略模式"><a href="#什么时候用策略模式" class="headerlink" title="什么时候用策略模式"></a>什么时候用策略模式</h1><p>在java的编码中，为了消除和避免大段的if else语句，我们常常会使用<strong>策略模式</strong>，来使得代码结构变得清晰可维护。<br>下面说一下我在写代码中的一个真实的例子，写的时候自己思考的，后来看《effective java》恰好验证了这个小技巧，还是蛮爽的。</p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><h2 id="策略模式标准写法"><a href="#策略模式标准写法" class="headerlink" title="策略模式标准写法"></a>策略模式标准写法</h2><ol>
<li><p>定义一个策略接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strategy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preProcessClient</span><span class="params">(xxx)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preResponseAdsRefill</span><span class="params">(xxx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理依赖于接口，构造函数中传入实例化好的策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Process.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前的处理方式</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Process</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preProcessClient</span><span class="params">(xxx)</span> </span>&#123;</span><br><span class="line">        strategy.preProcessClient(xxx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preResponseAdsRefill</span><span class="params">(xxx)</span> </span>&#123;</span><br><span class="line">        strategy.preResponseAdsRefill(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现接口</p>
</li>
</ol><a id="more"></a>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>其实很多时候处理的策略都是一样的，没有必要每一次请求过来都<code>new</code>一个<code>Strategy</code>出来，所以在process 加一个“单例”进行管理即可，把策略的解析下移到Process中，因为我们通常需要根据某些参数确定是什么策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Process.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Key, Strategy&gt; Key2Strategy = <span class="keyword">new</span> EnumMap&lt;&gt;(Key.class);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       Key2Strategy.put(Key.A, <span class="keyword">new</span> aStrategy());</span><br><span class="line">       Key2Strategy.put(Key.B, <span class="keyword">new</span> bStrategy());</span><br><span class="line">       Key2Strategy.put(Key.C, <span class="keyword">new</span> cStrategy());</span><br><span class="line">       Key2Strategy.put(Key.D, <span class="keyword">new</span> dStrategy());</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//当前的处理方式</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Process</span><span class="params">(xxx)</span> </span>&#123;<span class="comment">//xxx为可以确定策略的对象</span></span><br><span class="line">        <span class="comment">//解析，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Process</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preProcessClient</span><span class="params">(xxx)</span> </span>&#123;</span><br><span class="line">        strategy.preProcessClient(xxx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preResponseAdsRefill</span><span class="params">(xxx)</span> </span>&#123;</span><br><span class="line">        strategy.preResponseAdsRefill(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>策略模式如果策略类太多怎么办，这个问题一直困扰我，但是<a href="https://www.zhihu.com/question/28724321" target="_blank" rel="noopener">轮子哥在知乎上的一个回答</a>说的好:</p>
<blockquote>
<p>你的业务逻辑这么复杂，不要妄图使用简单的代码就能解决问题。代码的复杂程度是直接跟你的需求呈正比的。</p>
</blockquote>
<hr>
<blockquote>
<p>Talk is cheap, show me your code            ——.Linus Torvalds</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线上问题定位总结</title>
    <url>/2019/09/28/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="1-查看消耗资源最多的线程"><a href="#1-查看消耗资源最多的线程" class="headerlink" title="1.查看消耗资源最多的线程"></a>1.查看消耗资源最多的线程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -H -p $pid</span><br><span class="line"><span class="meta">$</span>pid: 要分析程序的进程ID</span><br></pre></td></tr></table></figure><p>我们将用top命令得出pid，<a href="http://tool.oschina.net/hexconvert" target="_blank" rel="noopener">换算</a>成十六进制， 例如：0x34ac8。</p><p>拿到了ID如何去对应堆栈信息里面的ID呢？</p><h2 id="2-使用jstack命令打出堆栈信息"><a href="#2-使用jstack命令打出堆栈信息" class="headerlink" title="2. 使用jstack命令打出堆栈信息"></a>2. 使用jstack命令打出堆栈信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstack $pid</span><br><span class="line"><span class="meta">$</span>pid: 要分析程序的进程ID</span><br></pre></td></tr></table></figure><a id="more"></a>





<p>执行上述命令后，会打印出pid的堆栈信息，为了方便起见，可以重定向到文件中，然后使用grep命令查找字符串0x34ac8。</p>
<h2 id="3-CPU耗时分析"><a href="#3-CPU耗时分析" class="headerlink" title="3.CPU耗时分析"></a>3.CPU耗时分析</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash busy_threads.sh -p $pid -c $cnt</span><br><span class="line"><span class="meta">$</span>pid: 要分析程序的进程ID</span><br><span class="line"><span class="meta">$</span>cnt: top排名个数</span><br></pre></td></tr></table></figure>

<p><a href="线上问题总结/busy_threads.sh">busy_threads.sh</a></p>
<h1 id="case"><a href="#case" class="headerlink" title="case"></a>case</h1><h2 id="1-rpc调用超时"><a href="#1-rpc调用超时" class="headerlink" title="1. rpc调用超时"></a>1. rpc调用超时</h2><p>现象：上游服务99-percent 很高，大概是1kms的延时，但是下游的业务监控延时很低，大概是50ms。</p>
<p>原因：下游服务提供了A, B , C 三个接口，其中C接口是同步进行的，C接口耗尽了线程池里的线程。业务监控到的是实际执行的时间50ms，但是上游感受到的时间是：线程池队列等待的时间+实际的执行时间=1kms。定位到的方法是jstack发现很多被Block住的线程，最终临时解决的方法是先让下游改成异步调用，再继续定位问题。</p>
<h2 id="2-部分请求调用出错"><a href="#2-部分请求调用出错" class="headerlink" title="2. 部分请求调用出错"></a>2. 部分请求调用出错</h2><p>现象：app -&gt; query -&gt; delivery 。app -&gt; query，调用出错次数增加。query-&gt; delivery发现是Read TimeOut，delivery自身监控没问题，基于第1条的经验教训，查看了线程池有没有阻塞的情况，发现并没有线程阻塞，最终查看ReadTimeOut的exception Stack是在thrift结构中第2000行左右读超时，查看delivery改动，发现最终是多线程写入一个Map&lt;String,String&gt; ，不是一个线程安全的。</p>
<h2 id="3-服务雪崩效应"><a href="#3-服务雪崩效应" class="headerlink" title="3.服务雪崩效应"></a>3.服务雪崩效应</h2><p><img src="/2019/09/28/线上问题总结/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB.png" alt="线程池进行隔离"></p>
<p>通过线程池进行隔离、服务级别的熔断，有效的避免服务间的雪崩。</p>
<p><img src="/2019/09/28/线上问题总结/Fast-Fail.png" alt="快速失败"></p>
<p>如果一个集群中出现单点故障，广告业务中适合快速失败，不然一直拖垮整个集群，发生雪崩效应。</p>
<ul>
<li>服务的业务隔离，重要业务放在单独的服务上（DE和DE-APPSTORE）</li>
<li>今早失败，避免等待</li>
<li>连接池共享-&gt; 独享</li>
<li>负载均衡和熔断</li>
<li>降级服务</li>
<li>灰度发布和主动监控</li>
</ul>
<h1 id="4-GC优化"><a href="#4-GC优化" class="headerlink" title="4. GC优化"></a>4. GC优化</h1><p>用eclipse-collection 优化存储，防止频繁GC</p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池如何保证有序?</title>
    <url>/2020/05/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在生产环境中，用kafka来解耦是常用的技术手段。为了保证消息的顺序处理，会把相同属性(同一个人、同一个素材等) 的消息发往kafka同一个partition中。例如，在广告系统中，会把某一个ad的转化数据发送到同一个partition。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ad1 -&gt; [Ad1-msg1, Ad1-msg1, ...] -&gt; 顺序发到partition1</span><br><span class="line">Ad2 -&gt; [Ad2-msg1, Ad2-msg2, ...] -&gt; 顺序发到partition2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>这样做的初衷是<strong>希望对于同一个广告的消息，不要出现消费的时候先后顺序错乱</strong>。</p>
<p>但是这里有一个速度不匹配的问题——Consumer<strong>处理的速度</strong>往往是远远小于Consumer<strong>拉取消息的速度</strong>的，于是很多人就会想到用多线程加速。但是这会带来一个问题：同一个Ad的消息先后顺序错乱，背离我们的初衷。由此，引出我们今天的问题：<strong>线程池如何保证有序。</strong></p>
<p><img src="/2020/05/03/线程池如何保证有序/1.png" alt="问题描述"></p>
<h1 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h1><p>上面我们分析的思路是通过线程池来加速消息的处理，而消息顺序错乱也是由于引入线程池带来的。有一种方法比较简单粗暴且有效，<strong>加Partition，增加Consumer，每个Consumer使用单线程来处理</strong>。但是如果消息太多，部署成本就会上升，所以回到了线程池如何保证有序上来。我们希望实现这样一个线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor&lt;Integer&gt; executor = xxx;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(MyDto dto)</span> </span>&#123; <span class="comment">// kafka消费逻辑的入口</span></span><br><span class="line">  executor.executeEx(dto.getUserId(), () -&gt; &#123;</span><br><span class="line">    <span class="comment">// 实际消费逻辑</span></span><br><span class="line">    <span class="comment">// 相同的dto.getAdId()会保证是按照入队顺序串行执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经有同学实现好了，github地址：<a href="https://github.com/PhantomThief/simple-pool/blob/master/src/main/java/com/github/phantomthief/pool/KeyAffinityExecutor.java" target="_blank" rel="noopener">KeyAffinityExecutor</a>，在研究源码之前，笔者思考了如果自己要实现这样一个线程池，那我会怎么考虑？</p>
<ol>
<li>把相同key的msg只交给一个线程去处理，那就保证了它的顺序性；</li>
<li>不同key的msg交给不同的线程去处理；</li>
</ol>
<p>下面我们逐一来看这两个问题：</p>
<ol>
<li>关于把相同key的msg交给一个线程去处理，同时不想频繁的创建和销毁一个线程。我们可以声明一个核心线程数和最大线程数都是1的线程池即可：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,..., queue);</span><br><span class="line"><span class="comment">// 其中queue为阻塞队列</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不同key的msg交给不同的线程去处理。</li>
</ol>
<p>这条比较好理解，如果来了一个key，查看是不是有对应的线程池处理它。有，那么扔到上面声明的线程池中；没有，选择(新建)线程池来处理。</p>
<p>最终的实现原理如下图所示，最终我们的这个线程池里面会包含多个<strong>核心线程数=最大线程数=1</strong>的小线程池。</p>
<p><img src="/2020/05/03/线程池如何保证有序/2.png" alt="问题描述"></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>最关键的两个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyAffinity</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AutoCloseable</span>, <span class="title">Iterable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 核心方法, 从一个key选出线程池, 对应我们上面说的第1点.</span></span><br><span class="line">    <span class="function">V <span class="title">select</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="comment">// 当每一个key执行完之后回收处理这个key的线程池.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finishCall</span><span class="params">(K key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KeyAffinity</code> 的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyAffinityImpl</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">KeyAffinity</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">select</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        KeyRef keyRef = mapping.compute(key, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前没有相同的key处理的, 那么就new一个线程池(选择最空闲的线程池).</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            v.incrConcurrency();</span><br><span class="line">            <span class="comment">// 如果有相同的key, 那么返回这个线程池并处理.</span></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> keyRef.ref();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishCall</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于每一个key如果处理完了, 那么会清空.</span></span><br><span class="line">        mapping.computeIfPresent(key, (k, v) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (v.decrConcurrency()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KeyAffinityExecutor</code> 线程池执行主体:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyAffinityExecutor</span>&lt;<span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">KeyAffinity</span>&lt;<span class="title">K</span>, <span class="title">ListeningExecutorService</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 构造线程池.</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; <span class="function">KeyAffinityExecutor&lt;K&gt; <span class="title">newSerializingExecutor</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newKeyAffinityExecutor()</span><br><span class="line">                .count(parallelism)</span><br><span class="line">                .executor(<span class="keyword">new</span> Supplier&lt;ExecutorService&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        LinkedBlockingQueue&lt;Runnable&gt; queue;</span><br><span class="line">                        <span class="keyword">if</span> (queueBufferSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queueBufferSize) &#123;</span><br><span class="line">                              </span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable e)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        <span class="comment">// 1. put方法让提交任务的线程阻塞.</span></span><br><span class="line">                                        put(e);</span><br><span class="line">                                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                                        Thread.currentThread().interrupt();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 2.声明核心线程数=最大线程数的线程池 </span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, MILLISECONDS, queue, threadFactory);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">executeEx</span><span class="params">(K key, @Nonnull ThrowableRunnable&lt;Exception&gt; task)</span> </span>&#123;</span><br><span class="line">        checkNotNull(task);</span><br><span class="line">        <span class="comment">// 1. 选择相应的线程池</span></span><br><span class="line">        ListeningExecutorService service = select(key);</span><br><span class="line">        <span class="keyword">boolean</span> addCallback = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 提交任务.</span></span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123; <span class="comment">// pass to uncaught exception handler</span></span><br><span class="line">                    throwIfUnchecked(e);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 3.该任务执行完成后check对于该key对应的线程池要不要清空</span></span><br><span class="line">                    finishCall(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            addCallback = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!addCallback) &#123;</span><br><span class="line">                finishCall(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三个类，是实现该线程池最核心的三个方法，有兴趣的同学沿着我所列出的核心方法，可以看整个实现的技巧。祝进步。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>java类加载机制</title>
    <url>/2019/03/21/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>类加载机制：虚拟机把描述类的数据从class文件加载到类，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的java类型。</p><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。<br><strong>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</strong><br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。</p><a id="more"></a>

<blockquote>
<p>静态绑定：编译时绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</p>
</blockquote>
<blockquote>
<p>动态绑定：即运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是动态绑定的。</p>
</blockquote>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>1、通过一个类的全限定名来获取其定义的二进制字节流。</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<blockquote>
<p>复习: jvm运行时数据区分为: 方法区、堆、虚拟机stack、本地方法stack、程序计数器。其中方法区是是每个线程共享的，用于存储：被虚拟机加载的类信息、常量、静态变量。</p>
</blockquote>
<p>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>说到加载，那jvm是怎么把这些数据加载到内存的呢?答案是：通过<strong>类加载器</strong>。java中提供了这么几种类加载器:</p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载.</li>
</ul>
<p>他们之间存在继承关系，继承关系如下图：<br><img src="/2019/03/21/java类加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%85%B3%E7%B3%BB.png" alt="类加载器关系"></p>
<p>具体到代码里面：</p>
<p><img src="/2019/03/21/java类加载机制/%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%9B%BE.png" alt="加载器类图.png"></p>
<p>他们是继承关系，但是实际上是用组合来实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sun.misc.Launcher</span><br><span class="line">public Launcher() &#123;</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        //1. 扩展类加载器</span><br><span class="line">        try &#123;</span><br><span class="line">            //内部引用的是ClassLoader.</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; catch (IOException var10) &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create extension class loader&quot;, var10);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.应用程序加载器</span><br><span class="line">        try &#123;</span><br><span class="line">            //注意这里传入参数是上面的var1：扩展类加载器.</span><br><span class="line">            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释1出初始化了扩展类加载器，而真正的调用代码在静态内部类ExtClassLoader.class中的getExtClassLoader()中，我们接着看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> static class ExtClassLoader extends URLClassLoader &#123;</span><br><span class="line">        public static Launcher.ExtClassLoader getExtClassLoader() throws IOException &#123;</span><br><span class="line">            final File[] var0 = getExtDirs();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">                    public Launcher.ExtClassLoader run() throws IOException &#123;</span><br><span class="line">                        int var1 = var0.length;</span><br><span class="line"></span><br><span class="line">                        for(int var2 = 0; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(var0[var2]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //这里调用静态类生成.</span><br><span class="line">                        return new Launcher.ExtClassLoader(var0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; catch (PrivilegedActionException var2) &#123;</span><br><span class="line">                throw (IOException)var2.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ExtClassLoader(File[] var1) throws IOException &#123;</span><br><span class="line">            //调用父类,第二个参数表示了父加载类是哪个.</span><br><span class="line">            super(getExtURLs(var1), (ClassLoader)null, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(this).initLookupCache(this);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过观察代码我们发现：<strong>ExtClassLoader通过Launcher.ExtClassLoader()静态方法构造实例,构造时需要依赖父类的构造方法.这里就实现了它们的加载器父子关系。<br>AppCalssLoader也类似，有兴趣的可以看下。</strong></p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上</strong>，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>这样做的好处是什么?</p>
<blockquote>
<p>同一个类的定义：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p>
</blockquote>
<p><strong>Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系</strong>。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //实现双亲委派逻辑.</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求。<br>文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<ul>
<li>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li>
<li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li>
<li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li>
<li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。<br>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int value = 3;</span><br></pre></td></tr></table></figure>

<p> 那么变量value在准备阶段过后的初始值为0，而不是3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int value = 3；</span><br></pre></td></tr></table></figure>

<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>解析阶段是虚拟机将常量池中的<strong>符号引用转化为直接引用</strong>的过程。这就是我们当年学编译原理的“链接”阶段。</p>
<blockquote>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并<strong>不一定</strong>已经加载到了内存中。</p>
</blockquote>
<blockquote>
<p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标<strong>必定</strong>已经存在于内存之中了。</p>
</blockquote>
<p>1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p>
<p>2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：<br><img src="/2019/03/21/java类加载机制/%E8%A7%A3%E6%9E%90%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png" alt="解析查找流程"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Super&#123;</span><br><span class="line">	public static int m = 11;</span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;执行了super类静态语句块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Father extends Super&#123;</span><br><span class="line">	public static int m = 33;</span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;执行了父类静态语句块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Child extends Father&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;执行了子类静态语句块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class StaticTest&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		System.out.println(Child.m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行了super类静态语句块</span><br><span class="line">执行了父类静态语句块</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>如果注释掉Father类中对m定义的那一行，则输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行了super类静态语句块</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful学习总结</title>
    <url>/2019/08/25/restful%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>关于restful的文章，网上文章搞得我云里雾里，花了点时间整理了一下。</p><h1 id="rest-restful-restful-api"><a href="#rest-restful-restful-api" class="headerlink" title="rest, restful,restful-api"></a>rest, restful,restful-api</h1><p>rest, restful, restful, restful-api这几个词经常在各种博客里面出现.具体什么关系呢?这个要从软件架构设计风格说起.</p><p><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener"><strong>SOA(Service-oriented architecture)</strong></a>: 软件的主要元素是服务.</p><a id="more"></a>


<p><a href="https://en.wikipedia.org/wiki/Resource-oriented_architecture" target="_blank" rel="noopener"><strong>ROA(Resource-oriented architecture)</strong></a>: 软件的主要元素是资源.</p>
<p>这其实有点像面向过程编程和面向对象编程的区别。SOA视角中,软件就是由各种松耦合的服务组成的,一切都可以服务化.而在ROA视角中,软件是由资源组成的,一切软件都可以通过对资源的操作(CRUD)来完成.</p>
<p><strong>Rest(Resource Representational State Transfer )</strong>:ROA的实现有很多种.具体怎么来实现以资源为中心的软件架构? rest就是ROA在网络软件应用中的一种定义, 而restful服务是一种rest架构风格下的实现,引用一下wikipedia上的一段话。</p>
<blockquote>
<p>REST, describes a series of architectural constraints that exemplify how the web’s design emerged (ROA).</p>
</blockquote>
<blockquote>
<p>Representational State Transfer (REST) is an architectural style that defines a set of constraints and properties based on HTTP. Web Services that conform to the REST architectural style, or RESTful web services, provide interoperability between computer systems on the Internet. </p>
</blockquote>
<p>好像还是不太理解对<strong>资源</strong>的操作和<strong>服务化</strong>的区别。举个例子就好了：</p>
<p>就我当前维护的广告系统来说,假如我要对一个广告主的账户余额进行更改。</p>
<p>基于服务我们会这么考虑问题：</p>
<ol>
<li>账户相关的模块服务化,提供一个接口出来.</li>
<li>然后开始写<strong>相关逻辑</strong>.</li>
<li>写相关逻辑的时候需要check这个账户是不是合法账户，需要登录验证等操作</li>
<li>这些内部操作最后对调用方透明的，只需要给出一个updateBilling的接口.</li>
</ol>
<p>基于资源我们会这么考虑问题：</p>
<ol>
<li>对账户是不是合法我们可以用GET来对<strong>账户资源</strong>实现.</li>
<li>验证操作我们可以用GET来对<strong>账户信息资源</strong>实现.</li>
<li>更新账户余额我们可以用POST来对<strong>账户余额资源</strong>实现.</li>
</ol>
<p>所以，我开头才会说这有点像面向对象和面向过程的区别.</p>
<h2 id="restful约束-优点"><a href="#restful约束-优点" class="headerlink" title="restful约束/优点"></a><strong>restful约束/优点</strong></h2><p>前面说restful系统遵循一定的约束，具体有哪些约束呢？满足如下6条的约束就可以被称作rest风格的架构，下面摘自维基百科。</p>
<p>1.客户端-服务器结构。通过一个统一的接口来分开客户端和服务器，使得两者可以独立开发和演化。客户端的实现可以简化，而服务器可以更容易的满足可伸缩性的要求。</p>
<p>2.无状态。在不同的客户端请求之间，服务器并不保存客户端相关的上下文状态信息。任何客户端发出的每个请求都包含了服务器处理该请求所需的全部信息。</p>
<p>3.可缓存。客户端可以缓存服务器返回的响应结果。服务器可以定义响应结果的缓存设置。</p>
<p>4.分层的系统。在分层的系统中，可能有中间服务器来处理安全策略和缓存等相关问题，以提高系统的可伸缩性。客户端并不需要了解中间的这些层次的细节。</p>
<p>5.按需代码（可选）。服务器可以通过传输可执行代码的方式来扩展或自定义客户端的行为。这是一个可选的约束。</p>
<p>6.统一接口。该约束是 REST 服务的基础，是客户端和服务器之间的桥梁。该约束又包含下面 4 个子约束。</p>
<ul>
<li>资源标识符。每个资源都有各自的标识符。客户端在请求时需要指定该标识符。在 REST 服务中，该标识符通常是 URI。</li>
<li>通过资源的表达来操纵资源。客户端根据所得到的资源的表达中包含的信息来了解如何操纵资源，比如对资源进行修改或删除。</li>
<li>自描述的消息。每条消息都包含足够的信息来描述如何处理该消息。</li>
<li>超媒体作为应用状态的引擎（HATEOAS）。客户端通过服务器提供的超媒体内容中动态提供的动作来进行状态转换。</li>
</ul>
<p>解释一下啥是<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>（<strong>Hypermedia As The Engine Of Application State)</strong>。客户端与服务器的交互完全由超媒体动态提供，客户端无需事先了解如何与数据或者服务器交互，所有的客户端后续行为完全由服务端的返回决定。相反，如果是SOA风格需要定义IDL。举例:</p>
<p>如下获取账户资源的请求，需要返回用XML格式表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /account/12345 HTTP/1.1</span><br><span class="line">Host: bank.example.com</span><br><span class="line">Accept: application/xml</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>返回结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: ...</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;account&gt;</span><br><span class="line">    &lt;account_number&gt;12345&lt;/account_number&gt;</span><br><span class="line">    &lt;balance currency=&quot;usd&quot;&gt;100.00&lt;/balance&gt;</span><br><span class="line">    &lt;link rel=&quot;deposit&quot; href=&quot;https://bank.example.com/accounts/12345?deposit=12345&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;withdraw&quot; href=&quot;https://bank.example.com/accounts/12345?withdraw=12345&quot; /&gt; </span><br><span class="line">    &lt;link rel=&quot;transfer&quot; href=&quot;https://bank.example.com/accounts/12345?transfer=2345&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;close&quot; href=&quot;https://bank.example.com/accounts/12345?status=close&quot; /&gt;</span><br><span class="line">&lt;/account&gt;</span><br></pre></td></tr></table></figure>

<p>表示现在可以执行：存款、提款、转账、销户的操作，这些操作放在了link中。</p>
<p>假如账户余额不足，返回结果会是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: ...</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;account&gt;</span><br><span class="line">    &lt;account_number&gt;12345&lt;/account_number&gt;</span><br><span class="line">    &lt;balance currency=&quot;usd&quot;&gt;-25.00&lt;/balance&gt;</span><br><span class="line">    &lt;link rel=&quot;deposit&quot; href=&quot;https://bank.example.com/account/12345?deposit=12345&quot; /&gt;</span><br><span class="line">&lt;/account&gt;</span><br></pre></td></tr></table></figure>

<p>这样link中的结果可执行的操作只有存款这一种, 其他的链接是不可用的，所以称之为：<strong>应用状态引擎（Engine Of Application State）。</strong>客户端可能的状态依赖于资源的状态，客户端无需知道每种描述信息和交互机制，如果需要解析新的信息格式，可以依赖于第五点：按需定制代码。</p>
<p>最大的特点是落到<strong>基于资源、接口统一</strong>上。把所有东西抽象成资源，把<strong>操作协议统一</strong>了，系统之间的配合就有了一定的约束，将减小服务对接(撕逼)成本，这是Self-descriptive messages的基础， cache的基础。至于分层啥的，我觉得这不是每种架构风格的标配么。</p>
<h2 id="REST-vs-SOA"><a href="#REST-vs-SOA" class="headerlink" title="REST vs SOA"></a><strong>REST vs SOA</strong></h2><p>REST-service</p>
<ul>
<li>网络上的资源都被抽象为资源，这些资源都具有唯一的统一资源标识符(URI：Uniform Resource Identiter)</li>
<li>通过HTTP协议的标准动作(Get、Put、Post、Delete)通过统一的接口对资源进行操作</li>
<li>无状态</li>
<li>基于HTTP</li>
<li>可以描述信息，比如信息是XML、zip、json、pdf</li>
</ul>
<p>SOA-service</p>
<ul>
<li>通过网络终结点对外提供服务。</li>
<li>通过调用服务接口实现软件</li>
<li>可以有状态</li>
<li>可以基于多种协议</li>
<li>信息需要依赖于接口对接双方约定.</li>
</ul>
<h2 id="restful-api设计"><a href="#restful-api设计" class="headerlink" title="restful-api设计"></a><strong>restful-api设计</strong></h2><p>这里推荐一下:<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">阮一峰的博客</a>，毕竟我没有在大型复杂项目中实践过。不过文中说把版本号放url中，另一篇博客<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="noopener">理解RESTful架构</a>又说最好版本号不要放在url中，应该是错误吧，知道的同学回答下。</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul>
<li><a href="https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/RESTSOAFuture/%23theCommentsSection" target="_blank" rel="noopener">REST会是SOA的未来吗？</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">Representational state transfer</a></li>
<li><a href="https://www.zhihu.com/question/33959971" target="_blank" rel="noopener">REST风格的优势是什么？</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-SpringHATEOAS/</a></li>
</ul>
<ul>
<li>(<a href="https://www.zhihu.com/question/33959971" target="_blank" rel="noopener">https://www.zhihu.com/question/33959971</a>)</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁的集中实现方式</title>
    <url>/2019/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="三种实现"><a href="#三种实现" class="headerlink" title="三种实现"></a>三种实现</h1><ul>
<li>基于缓存(Redis)</li>
<li>基于ZK</li>
<li>基于DB</li>
</ul><h1 id="需要满足的条件"><a href="#需要满足的条件" class="headerlink" title="需要满足的条件"></a>需要满足的条件</h1><ul>
<li>在分布式集群中，同一个方法在同一时间只能被同一台机器上的一个线程执行</li>
<li>可重入，避免死锁</li>
<li>最好是阻塞的</li>
<li>有高可用的获取锁和释放锁功能</li>
<li>获取锁和释放锁的性能要好</li>
</ul><h1 id="基于DB"><a href="#基于DB" class="headerlink" title="基于DB"></a>基于DB</h1><h2 id="基于表"><a href="#基于表" class="headerlink" title="基于表"></a>基于表</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>创建一张表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>锁住方法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>

<p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>释放锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁；做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li>
<li>这把锁只能是<strong>非阻塞</strong>的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作； 可以搞一个while循环，直到insert成功再返回成功。</li>
<li>这把锁是<strong>非重入</strong>的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了；在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
<h2 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。可以通过<strong>数据库的排他锁</strong>来实现分布式锁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="comment">// 在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁</span></span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mysql InnoDB 引擎：</p>
<ul>
<li>只有通过索引进行检索的时候才会使用行级锁；</li>
<li>不通过索引进行检索，使用表级锁；</li>
</ul>
<p>获得排他锁 = 获得分布式锁。在获取锁之后记得释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>阻塞锁[DONE]。<code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li>
<li>锁释放问题[DONE]。使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li>
<li>数据库单点[NOT DONE]。</li>
<li>可重入的问题[NOT DONE]。</li>
<li>表级锁问题。虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。</li>
</ul>
<h1 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用Redis命令<code>SETNX</code> (SET if Not eXists)。代表的是如果存在就不设置。</p>
<p><code>SETNX lock.id &lt;current Unix time + lock timeout + 1&gt;</code></p>
<ul>
<li>返回1, 该进程获得锁；</li>
<li>返回0，说明其他进程已经获得了锁，进程不能进入临界区。</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ul>
<li>死锁。个线程获取了锁之后，断开了与Redis 的连接，锁没有及时释放，竞争该锁的其他线程都会hung，产生死锁的情况。可以通过引入超时时间来解决，但是又会引入如下问题。</li>
<li>锁超时后，DEL竞态问题。在使用 SETNX 获得锁时，我们将键 lock.id 的值设置为锁的有效时间，线程获得锁后，其他线程还会不断的检测锁是否已超时，如果超时，等待的线程也将有机会获得锁。然而，锁超时，我们不能简单地使用 DEL 命令删除键 lock.id 以释放锁。</li>
</ul>
<blockquote>
<ol>
<li>A已经首先获得了锁 lock.id，然后线A断线。B,C都在等待竞争该锁；</li>
<li>B,C读取lock.id的值，比较当前时间和键 lock.id 的值来判断是否超时，发现超时；</li>
<li>B执行 DEL lock.id命令，并执行 SETNX lock.id 命令，并返回1，B获得锁；</li>
<li>C由于各刚刚检测到锁已超时，执行 DEL lock.id命令，将B刚刚设置的键 lock.id 删除，执行 SETNX lock.id命令，并返回1，即C获得锁。</li>
</ol>
</blockquote>
<p>在检测到锁超时后，线程不能直接简单地执行 DEL 删除键的操作以获得锁。</p>
<ul>
<li>GETSET 操作， 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</li>
</ul>
<blockquote>
<ol>
<li>A已经首先获得了锁 lock.id，然后线A断线。B,C都在等待竞争该锁；</li>
<li>B,C读取lock.id的值，比较当前时间和键 lock.id 的值来判断是否超时，发现超时；</li>
<li>B检测到锁已超时，即当前的时间大于键 lock.id 的值，B会执行<br><code>GETSET lock.id &lt;current Unix timestamp + lock timeout + 1&gt;</code>设置时间戳，通过比较键 lock.id 的旧值是否小于当前时间，判断进程是否已获得锁；</li>
<li>B发现GETSET返回的值小于当前时间，则执行 DEL lock.id命令，并执行 SETNX lock.id 命令，并返回1，B获得锁；</li>
<li>C执行GETSET得到的时间大于当前时间，则继续等待。</li>
</ol>
</blockquote>
<h1 id="基于ZK"><a href="#基于ZK" class="headerlink" title="基于ZK"></a>基于ZK</h1><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<p><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" target="_blank" rel="noopener">基于ZK的分布式锁实现方式</a></p>
<p>来看下Zookeeper能不能解决前面提到的问题：</p>
<ul>
<li>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li>
<li>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li>
<li>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li>
<li>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ul>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p><strong>性能</strong>上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</p>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p>
<h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p>
<h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p>
<h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p>
<h1 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h1><ul>
<li>定时任务管理平台。</li>
</ul>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
</search>
